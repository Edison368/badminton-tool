<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ç¾½æ¯›çƒåˆ†ç»„å·¥å…·</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      background: #f4f4f4;
      color: #000;
    }

    header {
      display: flex;
      align-items: center;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    header img {
      height: 50px;
      margin-right: 15px;
    }

    h2 {
      margin: 0;
      font-size: 28px;
      font-weight: bold;
    }

    label {
      font-weight: bold;
      font-size: 18px;
    }

    input, button, textarea, select {
      padding: 8px;
      margin-top: 5px;
      margin-bottom: 15px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 16px;
    }

    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 18px;
    }

    button:hover {
      background-color: #45a049;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
      background-color: white;
      border-radius: 10px;
      overflow: hidden;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 12px;
      text-align: center;
      font-size: 16px;
    }

    th {
      background-color: #4CAF50;
      color: white;
    }

    .result {
      margin-top: 20px;
      background-color: rgba(255,255,255,0.95);
      padding: 20px;
      border-radius: 10px;
    }

    .inputs {
      display: flex;
      flex-direction: column;
      max-width: 900px;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }

    .input-group {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
    }

    .input-group input, .input-group textarea {
      width: 48%;
    }

    .flex-row {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    .flex-child {
      flex: 1;
      min-width: 250px;
    }

    @media (max-width: 600px) {
      .flex-row {
        flex-direction: column;
      }
      h2 {
        font-size: 22px;
      }
      input, textarea, button {
        font-size: 16px;
      }
      label {
        font-size: 16px;
      }
    }

    .bold-text {
      font-weight: bold;
      color: black;
    }

    #shareLink {
      margin-top: 5px;
      width: 100%;
    }

    .rest-controls {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      border: 1px solid #dee2e6;
    }

    .rest-item {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .rest-item select, .rest-item input {
      flex: 1;
    }

    .rest-item button {
      flex: 0 0 auto;
      padding: 8px 12px;
      background-color: #dc3545;
    }

    .rest-item button:hover {
      background-color: #c82333;
    }

    #addRestBtn {
      background-color: #17a2b8;
    }

    #addRestBtn:hover {
      background-color: #138496;
    }

    .popup-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    .popup-content {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .popup-title {
      font-size: 24px;
      font-weight: bold;
      color: #2e7d32;
    }

    .close-popup {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #6c757d;
    }

    .dynamics-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }

    .court-members {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .court-box {
      background-color: white;
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      border: 1px solid #dee2e6;
    }

    .court-title {
      font-weight: bold;
      color: #2e7d32;
      margin-bottom: 8px;
      font-size: 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .court-round-control {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .court-round-control input {
      width: 50px;
    }

    .member-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    .member-list li {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }

    .member-list li:last-child {
      border-bottom: none;
    }

    .free-practice {
      color: #6c757d;
      font-style: italic;
    }

    .tab-container {
      display: flex;
      margin-bottom: 20px;
    }

    .tab {
      padding: 10px 20px;
      background-color: #e0e0e0;
      border: none;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }

    .tab.active {
      background-color: #4CAF50;
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .player-table {
      width: 100%;
      margin-bottom: 20px;
    }

    .player-table th {
      background-color: #4CAF50;
      color: white;
    }

    .player-table td {
      vertical-align: middle;
    }

    .player-table button {
      padding: 5px 10px;
      font-size: 14px;
    }

    .event-form {
      background-color: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      border: 1px solid #dee2e6;
    }

    .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .form-group {
      flex: 1;
      min-width: 200px;
    }

    .pairing-stats {
      margin-top: 20px;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
    }

    .pairing-stats h3 {
      margin-top: 0;
    }

    .pairing-type {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 5px;
    }

    .pairing-type.men {
      background-color: #2196F3;
      color: white;
    }

    .pairing-type.women {
      background-color: #E91E63;
      color: white;
    }

    .pairing-type.mix {
      background-color: #4CAF50;
      color: white;
    }

    .generation-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .generation-buttons button {
      flex: 1;
      min-width: 150px;
    }

    #generateAny {
      background-color: #9E9E9E;
    }

    #generateMix {
      background-color: #4CAF50;
    }

    #generateMen {
      background-color: #2196F3;
    }

    #generateWomen {
      background-color: #E91E63;
    }

    .new-window-btn {
      background-color: #673AB7;
      margin-top: 10px;
    }

    .warning-message {
      color: #d32f2f;
      font-weight: bold;
      margin: 10px 0;
    }

    .level-diff-warning {
      color: #FF9800;
      font-weight: bold;
    }

    .player-count-info {
      background-color: #e3f2fd;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 15px;
      font-weight: bold;
    }

    .remaining-players {
      color: #616161;
      font-style: italic;
      margin-top: 5px;
    }

    /* çº§åˆ«æ»‘å—æ ·å¼ */
    .level-slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }

    .level-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 10px;
      border-radius: 5px;
      background: #d3d3d3;
      outline: none;
    }

    .level-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
    }

    .level-slider::-moz-range-thumb {
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background: #4CAF50;
      cursor: pointer;
    }

    .level-marks {
      display: flex;
      justify-content: space-between;
      margin-top: -10px;
    }

    .level-mark {
      font-size: 12px;
      color: #666;
    }

    .unpaired-highlight {
      background-color: #fffde7;
    }
    
    /* å›ºå®šé…å¯¹æ ·å¼ */
    .fixed-pair-controls {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      border: 1px solid #dee2e6;
    }
    
    .fixed-pair-item {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .fixed-pair-item select, .fixed-pair-item input {
      flex: 1;
    }
    
    .fixed-pair-item button {
      flex: 0 0 auto;
      padding: 8px 12px;
      background-color: #dc3545;
    }
    
    .fixed-pair-item button:hover {
      background-color: #c82333;
    }
    
    #addFixedPairBtn {
      background-color: #FF9800;
    }
    
    #addFixedPairBtn:hover {
      background-color: #F57C00;
    }
    
    .fixed-pair-highlight {
      background-color: #e8f5e9;
    }
    
    /* å‚åŠ è½®æ¬¡æ ·å¼ */
    .join-round-controls {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      border: 1px solid #dee2e6;
    }
    
    .join-round-item {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .join-round-item select, .join-round-item input {
      flex: 1;
    }
    
    .join-round-item button {
      flex: 0 0 auto;
      padding: 8px 12px;
      background-color: #dc3545;
    }
    
    .join-round-item button:hover {
      background-color: #c82333;
    }
    
    #addJoinRoundBtn {
      background-color: #9C27B0;
    }
    
    #addJoinRoundBtn:hover {
      background-color: #7B1FA2;
    }

    /* å›¢é˜Ÿæ³¨å†Œæ ·å¼ */
    .team-registration {
      background-color: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      border: 1px solid #dee2e6;
    }

    .team-list {
      margin-top: 20px;
    }

    .team-item {
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      border: 1px solid #dee2e6;
    }

    .team-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .team-name {
      font-weight: bold;
      font-size: 18px;
    }

    .team-members {
      margin-top: 10px;
    }

    .member-item {
      display: flex;
      align-items: center;
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }

    .member-item:last-child {
      border-bottom: none;
    }

    .member-checkbox {
      margin-right: 10px;
    }

    .member-details {
      flex: 1;
      display: flex;
      justify-content: space-between;
    }

    .member-name {
      font-weight: bold;
    }

    .member-level {
      color: #666;
    }

    .member-gender {
      color: #666;
    }

    .team-actions {
      display: flex;
      gap: 10px;
    }

    .team-actions button {
      padding: 5px 10px;
      font-size: 14px;
    }

    .team-form {
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .member-form {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .member-form input, .member-form select {
      flex: 1;
    }

    .add-member-btn {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
    }

    .add-member-btn:hover {
      background-color: #45a049;
    }

    .save-team-btn {
      background-color: #2196F3;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
    }

    .save-team-btn:hover {
      background-color: #0b7dda;
    }

    .delete-team-btn {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
    }

    .delete-team-btn:hover {
      background-color: #c82333;
    }

    .team-selector {
      margin-bottom: 20px;
    }

    .team-selector select {
      width: 100%;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    .selected-members {
      margin-top: 20px;
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      border: 1px solid #dee2e6;
    }

    .selected-members h3 {
      margin-top: 0;
      margin-bottom: 10px;
    }

    .selected-members-list {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    .selected-members-list li {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }

    .selected-members-list li:last-child {
      border-bottom: none;
    }

    /* æ‰¹é‡é€‰æ‹©/æ¸…é™¤æŒ‰é’®æ ·å¼ */
    .batch-selection-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .batch-selection-buttons button {
      flex: 1;
      padding: 8px 12px;
      font-size: 14px;
    }

    #selectAllMembers {
      background-color: #4CAF50;
    }

    #clearSelectedMembers {
      background-color: #dc3545;
    }

    #clearRegisteredPlayers {
      background-color: #dc3545;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <header>
    <img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTaFxuFtnA0V3zsmO_XSDUVFhbErsh_851E8w&s" alt="Logo">
    <h2>ğŸ¸ ç¾½æ¯›çƒåˆ†ç»„å·¥å…·</h2>
  </header>

  <div class="tab-container">
    <button class="tab active" onclick="openTab(event, 'teamRegistrationTab')">å›¢é˜Ÿæ³¨å†Œ</button>
    <button class="tab" onclick="openTab(event, 'eventTab')">æ´»åŠ¨æ³¨å†Œ</button>
    <button class="tab" onclick="openTab(event, 'teamTab')">å›¢é˜Ÿåˆ†ç»„</button>
  </div>

  <!-- å›¢é˜Ÿæ³¨å†Œæ ‡ç­¾é¡µ -->
  <div id="teamRegistrationTab" class="tab-content active">
    <div class="team-registration">
      <h3>å›¢é˜Ÿæ³¨å†Œ</h3>
      
      <div class="team-form">
        <div class="form-group">
          <label for="teamName">å›¢é˜Ÿåç§°:</label>
          <input type="text" id="teamName" placeholder="è¾“å…¥å›¢é˜Ÿåç§°">
        </div>
        
        <h4>æ·»åŠ æˆå‘˜</h4>
        <div class="member-form">
          <input type="text" id="memberName" placeholder="å§“å">
          <select id="memberGender">
            <option value="male">ç”·</option>
            <option value="female">å¥³</option>
          </select>
          <input type="number" id="memberLevel" min="1" max="5" value="3" placeholder="æ°´å¹³">
          <button class="add-member-btn" onclick="addMemberToTeam()">æ·»åŠ </button>
        </div>
        
        <div id="teamMembersList">
          <!-- æ·»åŠ çš„æˆå‘˜å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
        </div>
        
        <button class="save-team-btn" onclick="saveTeam()">ä¿å­˜å›¢é˜Ÿ</button>
      </div>
      
      <div class="team-list" id="teamList">
        <!-- æ³¨å†Œçš„å›¢é˜Ÿå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
      </div>
    </div>
    
    <div class="team-selector">
      <h3>é€‰æ‹©å›¢é˜Ÿ</h3>
      <select id="teamSelector" onchange="loadTeamMembers()">
        <option value="">è¯·é€‰æ‹©å›¢é˜Ÿ</option>
      </select>
    </div>
    
    <div class="selected-members">
      <h3>å·²é€‰æˆå‘˜</h3>
      <div class="batch-selection-buttons">
        <button id="selectAllMembers" onclick="selectAllMembers()">å…¨é€‰æˆå‘˜</button>
        <button id="clearSelectedMembers" onclick="clearSelectedMembers()">æ¸…é™¤é€‰æ‹©</button>
      </div>
      <ul class="selected-members-list" id="selectedMembersList">
        <!-- é€‰æ‹©çš„æˆå‘˜å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
      </ul>
      <button onclick="addSelectedMembersToEvent()">å°†é€‰ä¸­æˆå‘˜æ·»åŠ åˆ°æ´»åŠ¨</button>
    </div>
  </div>

  <!-- æ´»åŠ¨æ³¨å†Œæ ‡ç­¾é¡µ -->
  <div id="eventTab" class="tab-content">
    <div class="event-form">
      <h3>æ´»åŠ¨ä¿¡æ¯</h3>
      <div class="form-row">
        <div class="form-group">
          <label>æ´»åŠ¨åç§°:</label>
          <input type="text" id="eventName" placeholder="ç¾½æ¯›çƒäº¤æµä¼š">
        </div>
        <div class="form-group">
          <label>åœ°ç‚¹:</label>
          <input type="text" id="eventLocation" placeholder="ä½“è‚²ä¸­å¿ƒ">
        </div>
      </div>
      <div class="form-row">
        <div class="form-group">
          <label>æ—¥æœŸ:</label>
          <input type="date" id="eventDate">
        </div>
        <div class="form-group">
          <label>æ—¶é—´:</label>
          <input type="time" id="eventTime">
        </div>
      </div>
    </div>

    <h3>çƒå‘˜æ³¨å†Œ</h3>
    <div class="flex-row">
      <div class="flex-child input-group">
        <label>çƒå‘˜å§“å:</label>
        <input type="text" id="newPlayerName" placeholder="è¾“å…¥å§“å">
      </div>
      <div class="flex-child input-group">
        <label>æ°´å¹³:</label>
        <div class="level-slider-container">
          <input type="range" id="newPlayerLevel" class="level-slider" min="1" max="5" value="3" step="1">
          <span id="levelDisplay" class="level-value">3</span>
        </div>
        <div class="level-marks">
          <span class="level-mark">åˆçº§</span>
          <span class="level-mark">ä¸­çº§</span>
          <span class="level-mark">é«˜çº§</span>
        </div>
      </div>
      <div class="flex-child input-group">
        <label>æ€§åˆ«:</label>
        <select id="newPlayerGender">
          <option value="male">ç”·</option>
          <option value="female">å¥³</option>
        </select>
      </div>
      <div class="flex-child input-group">
        <label>å‚åŠ è½®æ¬¡:</label>
        <input type="number" id="newPlayerJoinRound" min="1" value="1" placeholder="å¼€å§‹å‚åŠ çš„è½®æ¬¡">
      </div>
    </div>
    <button onclick="addPlayer()">æ³¨å†Œçƒå‘˜</button>
    <button id="clearRegisteredPlayers" onclick="clearRegisteredPlayers()">æ¸…é™¤æ‰€æœ‰æ³¨å†Œçƒå‘˜</button>

    <h3>å·²æ³¨å†Œçƒå‘˜</h3>
    <table class="player-table">
      <thead>
        <tr>
          <th>å§“å</th>
          <th>æ°´å¹³</th>
          <th>æ€§åˆ«</th>
          <th>å‚åŠ è½®æ¬¡</th>
          <th>æ“ä½œ</th>
        </tr>
      </thead>
      <tbody id="registeredPlayers">
        <!-- æ³¨å†Œçš„çƒå‘˜å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ -->
      </tbody>
    </table>

    <button onclick="goToTeamDivision()" style="margin-top: 20px; background-color: #2196F3;">å‰å¾€åˆ†ç»„é¡µé¢</button>
  </div>

  <!-- å›¢é˜Ÿåˆ†ç»„æ ‡ç­¾é¡µ -->
  <div id="teamTab" class="tab-content">
    <div class="inputs">
      <label>åœºåœ°æ•°é‡ï¼š<input type="number" id="courtCount" min="1" /></label>
      <label>æ€»è½®æ¬¡æ•°ï¼š<input type="number" id="totalRounds" min="1" value="1" /></label>

      <div class="flex-row">
        <div class="flex-child input-group">
          <label>çƒå‘˜å§“åï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ï¼š</label>
          <textarea id="playerNames" rows="3" placeholder="æé›¨è¾°\nå¼ é¦¨æœˆ\nå´”å˜‰è¨€\nè’‹æ¢“ç¿\nç™½æ˜Šå¤©\nå”èŠ·è‹¥\næ—è¯­å«£\néŸ©å­è±ª\néƒ­\næ—ä¸¹\nLCW\næ¡ƒç”°\nå±±å£èŒœ\nå®«å´å‹é¦™\nå¥ˆç»ª\né¦™ç»‡\nåŸç²ä½³\né‡‘\næ¡¥"></textarea>
        </div>
        <div class="flex-child input-group">
          <label>æ°´å¹³ï¼ˆ1-5ï¼Œç•™ç©ºè‡ªåŠ¨åˆ†é…ï¼‰ï¼š</label>
          <textarea id="playerLevels" rows="3" placeholder="3\n2\n4\n2\n3\n2\n2\n4\n3\n5\n5\n4\n3\n2\n2\n2\n3\n4\n2"></textarea>
        </div>
        <div class="flex-child input-group">
          <label>æ€§åˆ«ï¼ˆç”·/å¥³ï¼Œæ¯è¡Œä¸€ä¸ªï¼‰ï¼š</label>
          <textarea id="playerGenders" rows="3" placeholder="ç”·\nå¥³\nç”·\nå¥³\nç”·\nå¥³\nå¥³\nç”·\nç”·\nç”·\nç”·\nç”·\nå¥³\nå¥³\nå¥³\nå¥³\nå¥³\nå¥³\nå¥³"></textarea>
        </div>
        <div class="flex-child input-group">
          <label>å‚åŠ è½®æ¬¡ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ï¼š</label>
          <textarea id="playerJoinRounds" rows="3" placeholder="1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1"></textarea>
        </div>
      </div>

      <div class="rest-controls">
        <h3>ä¼‘æ¯è®¾ç½®</h3>
        <div id="restContainer">
          <!-- ä¼‘æ¯è®¾ç½®é¡¹å°†åœ¨è¿™é‡Œæ·»åŠ  -->
        </div>
        <button id="addRestBtn" onclick="addRestControl()">ï¼‹ æ·»åŠ ä¼‘æ¯è®¾ç½®</button>
      </div>
      
      <div class="fixed-pair-controls">
        <h3>å›ºå®šé…å¯¹è®¾ç½®</h3>
        <div id="fixedPairContainer">
          <!-- å›ºå®šé…å¯¹è®¾ç½®é¡¹å°†åœ¨è¿™é‡Œæ·»åŠ  -->
        </div>
        <button id="addFixedPairBtn" onclick="addFixedPairControl()">ï¼‹ æ·»åŠ å›ºå®šé…å¯¹</button>
      </div>
      
      <div class="join-round-controls">
        <h3>å‚åŠ è½®æ¬¡è®¾ç½®</h3>
        <div id="joinRoundContainer">
          <!-- å‚åŠ è½®æ¬¡è®¾ç½®é¡¹å°†åœ¨è¿™é‡Œæ·»åŠ  -->
        </div>
        <button id="addJoinRoundBtn" onclick="addJoinRoundControl()">ï¼‹ æ·»åŠ å‚åŠ è½®æ¬¡</button>
      </div>

      <div class="generation-buttons">
        <button id="generateAny" onclick="generateRounds('any')">éšæœºç”Ÿæˆ</button>
        <button id="generateMix" onclick="generateRounds('mix')">æ··åŒç”Ÿæˆ</button>
        <button id="generateMen" onclick="generateRounds('men')">ç”·åŒç”Ÿæˆ</button>
        <button id="generateWomen" onclick="generateRounds('women')">å¥³åŒç”Ÿæˆ</button>
      </div>

      <button onclick="showCourtDynamicsPopup()">ğŸ‘¥ æ˜¾ç¤ºåœºåœ°åŠ¨æ€</button>
      <button onclick="exportToExcel()" style="background-color: #2196F3;">ğŸ“Š å¯¼å‡ºåˆ°Excel</button>
      <button onclick="generateShareLink()">ğŸ”— ç”Ÿæˆåˆ†äº«é“¾æ¥</button>
      <button onclick="copyShareLink()">ğŸ“‹ å¤åˆ¶é“¾æ¥</button>
      <input type="text" id="shareLink" readonly />

      <!-- åœ¨æ–°çª—å£æ‰“å¼€æŒ‰é’® -->
      <button class="new-window-btn" onclick="openInNewWindow('any')">ğŸ–¥ï¸ éšæœºç”Ÿæˆ (æ–°çª—å£)</button>
      <button class="new-window-btn" onclick="openInNewWindow('mix')">ğŸ–¥ï¸ æ··åŒ (æ–°çª—å£)</button>
      <button class="new-window-btn" onclick="openInNewWindow('men')">ğŸ–¥ï¸ ç”·åŒ (æ–°çª—å£)</button>
      <button class="new-window-btn" onclick="openInNewWindow('women')">ğŸ–¥ï¸ å¥³åŒ (æ–°çª—å£)</button>
    </div>

    <div class="result" id="output"></div>
  </div>

  <!-- å¼¹å‡ºçª—å£ -->
  <div class="popup-overlay" id="courtDynamicsPopup">
    <div class="popup-content">
      <div class="popup-header">
        <div class="popup-title">åœºåœ°åŠ¨æ€æ˜¾ç¤º</div>
        <button class="close-popup" onclick="closeCourtDynamicsPopup()">Ã—</button>
      </div>
      <div id="dynamicsOutput"></div>
    </div>
  </div>

  <div style="margin: 20px 0;">
    <button onclick="saveData()" style="background-color: #ff9800;">ğŸ’¾ ä¿å­˜æ•°æ®</button>
    <button onclick="loadData()" style="background-color: #ff9800;">ğŸ“‚ åŠ è½½æ•°æ®</button>
    <button onclick="exportData()" style="background-color: #ff5722;">ğŸ“¤ å¯¼å‡º</button>
    <input type="file" id="importFile" accept=".json" onchange="importData(event)" style="display: none;">
    <button onclick="document.getElementById('importFile').click()" style="background-color: #ff5722;">ğŸ“¥ å¯¼å…¥</button>
  </div>

  <script>
    let playCountMap = {};
    let allPreviousPairs = [];
    let pairingCounts = {};
    let restSettings = [];
    let fixedPairs = []; // å­˜å‚¨å›ºå®šé…å¯¹è®¾ç½®çš„æ•°ç»„
    let joinRoundSettings = []; // å­˜å‚¨å‚åŠ è½®æ¬¡è®¾ç½®çš„æ•°ç»„
    let allRoundData = [];
    let courtRoundSettings = {};
    let registeredPlayers = [];
    let currentPairingType = 'any';
    let pairingHistory = {}; // è®°å½•å„é…å¯¹ç»„åˆçš„å†å²
    let playerLevelSumMap = {};
    let allPossiblePairs = [];
    let currentShareData = null;
    let lastPairingForPlayer = {}; // è®°å½•çƒå‘˜çš„æœ€åé…å¯¹
    let teams = []; // å­˜å‚¨å›¢é˜Ÿæ•°æ®çš„æ•°ç»„
    let currentTeamMembers = []; // å½“å‰ç¼–è¾‘ä¸­çš„å›¢é˜Ÿæˆå‘˜
    let selectedMembers = []; // é€‰ä¸­çš„æˆå‘˜

    // æ›´æ–°æ°´å¹³æ»‘å—æ˜¾ç¤ºå€¼çš„å‡½æ•°
    function updateLevelDisplay() {
      const levelValue = document.getElementById('newPlayerLevel').value;
      document.getElementById('levelDisplay').textContent = levelValue;
    }

    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨çš„å‡½æ•°
    function initializeLevelSlider() {
      const levelSlider = document.getElementById('newPlayerLevel');
      if (levelSlider) {
        levelSlider.addEventListener('input', updateLevelDisplay);
        // æ˜¾ç¤ºåˆå§‹å€¼
        updateLevelDisplay();
      }
    }

    function openTab(event, tabId) {
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.getElementById(tabId).classList.add('active');
      event.currentTarget.classList.add('active');
    }

    // å›¢é˜Ÿç›¸å…³å‡½æ•°
    function addMemberToTeam() {
      const name = document.getElementById('memberName').value.trim();
      const gender = document.getElementById('memberGender').value;
      const level = parseInt(document.getElementById('memberLevel').value);

      if (!name) {
        alert('è¯·è¾“å…¥æˆå‘˜å§“å');
        return;
      }

      if (isNaN(level) || level < 1 || level > 5) {
        alert('è¯·è¾“å…¥æ­£ç¡®çš„æ°´å¹³ (1-5)');
        return;
      }

      // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒåæˆå‘˜
      if (currentTeamMembers.some(member => member.name === name)) {
        alert('å·²å­˜åœ¨åŒåæˆå‘˜');
        return;
      }

      currentTeamMembers.push({ name, gender, level });
      updateTeamMembersList();

      // æ¸…ç©ºè¾“å…¥å­—æ®µ
      document.getElementById('memberName').value = '';
      document.getElementById('memberLevel').value = '3';
    }

    function updateTeamMembersList() {
      const container = document.getElementById('teamMembersList');
      container.innerHTML = '';

      if (currentTeamMembers.length === 0) {
        container.innerHTML = '<p>å°šæœªæ·»åŠ æˆå‘˜</p>';
        return;
      }

      const list = document.createElement('ul');
      list.style.listStyleType = 'none';
      list.style.padding = '0';

      currentTeamMembers.forEach((member, index) => {
        const item = document.createElement('li');
        item.style.display = 'flex';
        item.style.justifyContent = 'space-between';
        item.style.alignItems = 'center';
        item.style.padding = '8px 0';
        item.style.borderBottom = '1px solid #eee';

        const memberInfo = document.createElement('div');
        memberInfo.innerHTML = `
          <span style="font-weight: bold;">${member.name}</span>
          <span style="color: #666; margin-left: 10px;">æ°´å¹³: ${member.level}</span>
          <span style="color: #666; margin-left: 10px;">${member.gender === 'male' ? 'ç”·' : 'å¥³'}</span>
        `;

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.style.backgroundColor = '#dc3545';
        deleteBtn.style.color = 'white';
        deleteBtn.style.border = 'none';
        deleteBtn.style.padding = '5px 10px';
        deleteBtn.style.borderRadius = '5px';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.onclick = () => {
          currentTeamMembers.splice(index, 1);
          updateTeamMembersList();
        };

        item.appendChild(memberInfo);
        item.appendChild(deleteBtn);
        list.appendChild(item);
      });

      container.appendChild(list);
    }

    function saveTeam() {
      const teamName = document.getElementById('teamName').value.trim();

      if (!teamName) {
        alert('è¯·è¾“å…¥å›¢é˜Ÿåç§°');
        return;
      }

      if (currentTeamMembers.length === 0) {
        alert('è¯·æ·»åŠ æˆå‘˜');
        return;
      }

      // æ›´æ–°ç°æœ‰å›¢é˜Ÿæˆ–æ·»åŠ æ–°å›¢é˜Ÿ
      const existingTeamIndex = teams.findIndex(team => team.name === teamName);
      
      if (existingTeamIndex >= 0) {
        // æ›´æ–°ç°æœ‰å›¢é˜Ÿ
        teams[existingTeamIndex].members = [...currentTeamMembers];
      } else {
        // æ·»åŠ æ–°å›¢é˜Ÿ
        teams.push({
          name: teamName,
          members: [...currentTeamMembers]
        });
      }

      // æ›´æ–°å›¢é˜Ÿåˆ—è¡¨
      updateTeamList();
      
      // æ›´æ–°å›¢é˜Ÿé€‰æ‹©å™¨
      updateTeamSelector();
      
      // é‡ç½®è¡¨å•
      document.getElementById('teamName').value = '';
      currentTeamMembers = [];
      updateTeamMembersList();
      
      alert('å›¢é˜Ÿå·²ä¿å­˜');
    }

    function updateTeamList() {
      const container = document.getElementById('teamList');
      container.innerHTML = '';

      if (teams.length === 0) {
        container.innerHTML = '<p>æ²¡æœ‰æ³¨å†Œçš„å›¢é˜Ÿ</p>';
        return;
      }

      teams.forEach((team, teamIndex) => {
        const teamItem = document.createElement('div');
        teamItem.className = 'team-item';
        
        const teamHeader = document.createElement('div');
        teamHeader.className = 'team-header';
        
        const teamName = document.createElement('div');
        teamName.className = 'team-name';
        teamName.textContent = team.name;
        
        const teamActions = document.createElement('div');
        teamActions.className = 'team-actions';
        
        const editBtn = document.createElement('button');
        editBtn.textContent = 'ç¼–è¾‘';
        editBtn.style.backgroundColor = '#2196F3';
        editBtn.onclick = () => editTeam(teamIndex);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.style.backgroundColor = '#dc3545';
        deleteBtn.onclick = () => deleteTeam(teamIndex);
        
        teamActions.appendChild(editBtn);
        teamActions.appendChild(deleteBtn);
        teamHeader.appendChild(teamName);
        teamHeader.appendChild(teamActions);
        
        const membersList = document.createElement('div');
        membersList.className = 'team-members';
        
        team.members.forEach(member => {
          const memberItem = document.createElement('div');
          memberItem.className = 'member-item';
          
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.className = 'member-checkbox';
          checkbox.value = member.name;
          checkbox.onchange = (e) => toggleMemberSelection(member, e.target.checked);
          
          const memberDetails = document.createElement('div');
          memberDetails.className = 'member-details';
          
          const nameSpan = document.createElement('span');
          nameSpan.className = 'member-name';
          nameSpan.textContent = member.name;
          
          const levelSpan = document.createElement('span');
          levelSpan.className = 'member-level';
          levelSpan.textContent = `æ°´å¹³: ${member.level}`;
          
          const genderSpan = document.createElement('span');
          genderSpan.className = 'member-gender';
          genderSpan.textContent = member.gender === 'male' ? 'ç”·' : 'å¥³';
          
          memberDetails.appendChild(nameSpan);
          memberDetails.appendChild(levelSpan);
          memberDetails.appendChild(genderSpan);
          
          memberItem.appendChild(checkbox);
          memberItem.appendChild(memberDetails);
          membersList.appendChild(memberItem);
        });
        
        teamItem.appendChild(teamHeader);
        teamItem.appendChild(membersList);
        container.appendChild(teamItem);
      });
    }

    function updateTeamSelector() {
      const selector = document.getElementById('teamSelector');
      selector.innerHTML = '<option value="">è¯·é€‰æ‹©å›¢é˜Ÿ</option>';
      
      teams.forEach(team => {
        const option = document.createElement('option');
        option.value = team.name;
        option.textContent = team.name;
        selector.appendChild(option);
      });
    }

    function loadTeamMembers() {
      const teamName = document.getElementById('teamSelector').value;
      if (!teamName) return;
      
      const team = teams.find(t => t.name === teamName);
      if (!team) return;
      
      // æ›´æ–°å·²é€‰æˆå‘˜åˆ—è¡¨
      const selectedList = document.getElementById('selectedMembersList');
      selectedList.innerHTML = '';
      
      team.members.forEach(member => {
        const item = document.createElement('li');
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = selectedMembers.some(m => m.name === member.name);
        checkbox.onchange = (e) => toggleMemberSelection(member, e.target.checked);
        
        const memberInfo = document.createElement('span');
        memberInfo.textContent = `${member.name} (æ°´å¹³: ${member.level}, ${member.gender === 'male' ? 'ç”·' : 'å¥³'})`;
        
        item.appendChild(checkbox);
        item.appendChild(memberInfo);
        selectedList.appendChild(item);
      });
    }

    function toggleMemberSelection(member, isSelected) {
      if (isSelected) {
        // æ£€æŸ¥æ˜¯å¦å·²é€‰æ‹©
        if (!selectedMembers.some(m => m.name === member.name)) {
          selectedMembers.push(member);
        }
      } else {
        // ä»é€‰æ‹©ä¸­ç§»é™¤
        selectedMembers = selectedMembers.filter(m => m.name !== member.name);
      }
      
      updateSelectedMembersList();
    }

    function updateSelectedMembersList() {
      const container = document.getElementById('selectedMembersList');
      container.innerHTML = '';
      
      selectedMembers.forEach(member => {
        const item = document.createElement('li');
        item.textContent = `${member.name} (æ°´å¹³: ${member.level}, ${member.gender === 'male' ? 'ç”·' : 'å¥³'})`;
        container.appendChild(item);
      });
    }

    // å…¨é€‰æˆå‘˜å‡½æ•°
    function selectAllMembers() {
      const teamName = document.getElementById('teamSelector').value;
      if (!teamName) {
        alert('è¯·é€‰æ‹©å›¢é˜Ÿ');
        return;
      }
      
      const team = teams.find(t => t.name === teamName);
      if (!team) return;
      
      // é€‰æ‹©æ‰€æœ‰æˆå‘˜
      selectedMembers = [...team.members];
      
      // æ›´æ–°å¤é€‰æ¡†
      const checkboxes = document.querySelectorAll('.member-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true;
      });
      
      updateSelectedMembersList();
      alert('å·²å…¨é€‰æ‰€æœ‰æˆå‘˜');
    }

    // æ¸…é™¤é€‰æ‹©å‡½æ•°
    function clearSelectedMembers() {
      selectedMembers = [];
      
      // æ›´æ–°å¤é€‰æ¡†
      const checkboxes = document.querySelectorAll('.member-checkbox');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      
      updateSelectedMembersList();
      alert('å·²æ¸…é™¤é€‰æ‹©');
    }

    // æ¸…é™¤æ‰€æœ‰æ³¨å†Œçƒå‘˜å‡½æ•°
    function clearRegisteredPlayers() {
      if (confirm('ç¡®å®šè¦åˆ é™¤æ‰€æœ‰å·²æ³¨å†Œçƒå‘˜å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
        registeredPlayers = [];
        updateRegisteredPlayersList();
        updateTeamDivisionPlayers();
        alert('å·²æ¸…é™¤æ‰€æœ‰æ³¨å†Œçƒå‘˜');
      }
    }

    function addSelectedMembersToEvent() {
      if (selectedMembers.length === 0) {
        alert('è¯·é€‰æ‹©æˆå‘˜');
        return;
      }
      
      // åˆ‡æ¢åˆ°æ´»åŠ¨æ³¨å†Œæ ‡ç­¾é¡µ
      openTab({ currentTarget: document.querySelector('.tab-container button:nth-child(2)') }, 'eventTab');
      
      // å°†é€‰ä¸­æˆå‘˜æ·»åŠ åˆ°å·²æ³¨å†Œçƒå‘˜
      selectedMembers.forEach(member => {
        // æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ
        if (!registeredPlayers.some(p => p.name === member.name)) {
          registeredPlayers.push({
            name: member.name,
            level: member.level,
            gender: member.gender,
            joinRound: 1
          });
        }
      });
      
      updateRegisteredPlayersList();
      alert('å·²å°†é€‰ä¸­æˆå‘˜æ·»åŠ åˆ°æ´»åŠ¨');
    }

    function editTeam(teamIndex) {
      const team = teams[teamIndex];
      
      // åœ¨è¡¨å•ä¸­è®¾ç½®å›¢é˜Ÿä¿¡æ¯
      document.getElementById('teamName').value = team.name;
      currentTeamMembers = [...team.members];
      
      updateTeamMembersList();
      
      // åˆ‡æ¢åˆ°å›¢é˜Ÿæ³¨å†Œæ ‡ç­¾é¡µ
      openTab({ currentTarget: document.querySelector('.tab-container button:nth-child(1)') }, 'teamRegistrationTab');
    }

    function deleteTeam(teamIndex) {
      if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤å›¢é˜Ÿå—ï¼Ÿ')) {
        teams.splice(teamIndex, 1);
        updateTeamList();
        updateTeamSelector();
      }
    }

    function addPlayer() {
      const name = document.getElementById('newPlayerName').value.trim();
      const level = parseInt(document.getElementById('newPlayerLevel').value);
      const gender = document.getElementById('newPlayerGender').value;
      const joinRound = parseInt(document.getElementById('newPlayerJoinRound').value) || 1;

      if (!name) {
        alert('è¯·è¾“å…¥çƒå‘˜å§“å');
        return;
      }

      if (isNaN(level) || level < 1 || level > 5) {
        alert('è¯·è¾“å…¥æ­£ç¡®çš„æ°´å¹³ (1-5)');
        return;
      }

      if (registeredPlayers.some(player => player.name === name)) {
        alert('æ­¤å§“åå·²æ³¨å†Œ');
        return;
      }

      registeredPlayers.push({ name, level, gender, joinRound });
      updateRegisteredPlayersList();

      document.getElementById('newPlayerName').value = '';
      document.getElementById('newPlayerLevel').value = '3';
      document.getElementById('levelDisplay').textContent = '3';
      document.getElementById('newPlayerJoinRound').value = '1';
    }

    function removePlayer(index) {
      registeredPlayers.splice(index, 1);
      updateRegisteredPlayersList();
    }

    function updateRegisteredPlayersList() {
      const tbody = document.getElementById('registeredPlayers');
      tbody.innerHTML = '';

      let maleCount = 0;
      let femaleCount = 0;

      registeredPlayers.forEach((player, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${player.name}</td>
          <td>${player.level}</td>
          <td>${player.gender === 'male' ? 'ç”·' : 'å¥³'}</td>
          <td>${player.joinRound}</td>
          <td><button onclick="removePlayer(${index})" style="background-color: #dc3545;">åˆ é™¤</button></td>
        `;
        tbody.appendChild(row);

        if (player.gender === 'male') maleCount++;
        else femaleCount++;
      });

      const countInfo = document.createElement('div');
      countInfo.className = 'player-count-info';
      countInfo.innerHTML = `
        å·²æ³¨å†Œçƒå‘˜: ç”· ${maleCount}äºº, å¥³ ${femaleCount}äºº, æ€»è®¡ ${registeredPlayers.length}äºº
      `;
      tbody.parentNode.insertBefore(countInfo, tbody);

      updateTeamDivisionPlayers();
    }

    function updateTeamDivisionPlayers() {
      const namesTextarea = document.getElementById('playerNames');
      const levelsTextarea = document.getElementById('playerLevels');
      const gendersTextarea = document.getElementById('playerGenders');
      const joinRoundsTextarea = document.getElementById('playerJoinRounds');

      const names = registeredPlayers.map(player => player.name).join('\n');
      const levels = registeredPlayers.map(player => player.level).join('\n');
      const genders = registeredPlayers.map(player => player.gender).join('\n');
      const joinRounds = registeredPlayers.map(player => player.joinRound).join('\n');

      namesTextarea.value = names;
      levelsTextarea.value = levels;
      gendersTextarea.value = genders;
      joinRoundsTextarea.value = joinRounds;
      
      // æ›´æ–°çƒå‘˜é€‰æ‹©åˆ—è¡¨
      updatePlayerSelects();
    }

    function goToTeamDivision() {
      if (registeredPlayers.length === 0) {
        alert('è¯·å…ˆæ³¨å†Œçƒå‘˜');
        return;
      }

      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      document.getElementById('teamTab').classList.add('active');

      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector('.tab-container button:nth-child(3)').classList.add('active');

      updateTeamDivisionPlayers();
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function initializePairingCounts(players) {
      pairingCounts = {};
      pairingHistory = {};
      playerLevelSumMap = {};
      allPossiblePairs = [];
      lastPairingForPlayer = {};

      for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
          const pair = [players[i].name, players[j].name].sort().join(' & ');
          pairingCounts[pair] = 0;
          pairingHistory[pair] = []; // åˆå§‹åŒ–å„é…å¯¹ç»„åˆçš„å†å²
          playerLevelSumMap[pair] = players[i].level + players[j].level;
          allPossiblePairs.push(pair);
        }
      }
    }

    function getPairingType(pair, players) {
      const player1 = players.find(p => p.name === pair[0]);
      const player2 = players.find(p => p.name === pair[1]);

      if (!player1 || !player2) return 'unknown';

      if (player1.gender === 'male' && player2.gender === 'male') return 'men';
      if (player1.gender === 'female' && player2.gender === 'female') return 'women';
      return 'mix';
    }

    function createPairs(players, allPlayers, pairingType, roundNumber) {
      // æ ¹æ®å‚åŠ è½®æ¬¡ç­›é€‰çƒå‘˜
      const availablePlayers = players.filter(player => {
        const playerInfo = allPlayers.find(p => p.name === player[0]);
        return playerInfo && playerInfo.joinRound <= roundNumber;
      });

      // è·å–å½“å‰è½®æ¬¡çš„å›ºå®šé…å¯¹
      const roundFixedPairs = fixedPairs.filter(fp => fp.round === roundNumber);
      
      // å¦‚æœæœ‰å›ºå®šé…å¯¹ï¼Œä¼˜å…ˆå¤„ç†
      if (roundFixedPairs.length > 0) {
        const fixedPairPlayers = [];
        const fixedPairData = [];
        
        // æ”¶é›†å›ºå®šé…å¯¹çš„çƒå‘˜
        roundFixedPairs.forEach(fp => {
          const player1 = availablePlayers.find(p => p[0] === fp.player1);
          const player2 = availablePlayers.find(p => p[0] === fp.player2);
          
          if (player1 && player2) {
            fixedPairPlayers.push(fp.player1, fp.player2);
            fixedPairData.push([player1, player2]);
          }
        });
        
        // å›ºå®šé…å¯¹ä»¥å¤–çš„çƒå‘˜
        const remainingPlayers = availablePlayers.filter(p => !fixedPairPlayers.includes(p[0]));
        
        // ä»å›ºå®šé…å¯¹å’Œå‰©ä½™çƒå‘˜ä¸­ç”Ÿæˆé…å¯¹
        if (fixedPairData.length > 0 && remainingPlayers.length >= 2) {
          // å›ºå®šé…å¯¹ä¸­çš„ä¸€ä¸ª
          const fixedPair = fixedPairData[0];
          
          // ä»å‰©ä½™çƒå‘˜ä¸­é€‰æ‹©è€ƒè™‘æ°´å¹³å·®çš„2äºº
          const opponentPair = selectOpponentsConsideringLevel(fixedPair, remainingPlayers, allPlayers, pairingType);
          
          if (opponentPair.length === 2) {
            const pair1Key = [fixedPair[0][0], fixedPair[1][0]].sort().join(' & ');
            const pair2Key = [opponentPair[0][0], opponentPair[1][0]].sort().join(' & ');
            
            pairingCounts[pair1Key] = (pairingCounts[pair1Key] || 0) + 1;
            pairingCounts[pair2Key] = (pairingCounts[pair2Key] || 0) + 1;
            
            // æ›´æ–°é…å¯¹ç»„åˆå†å²
            pairingHistory[pair1Key].push({
              round: roundNumber,
              opponent: pair2Key,
              type: getPairingType([fixedPair[0][0], fixedPair[1][0]], allPlayers)
            });
            
            pairingHistory[pair2Key].push({
              round: roundNumber,
              opponent: pair1Key,
              type: getPairingType([opponentPair[0][0], opponentPair[1][0]], allPlayers)
            });
            
            fixedPair.forEach(player => playCountMap[player[0]]++);
            opponentPair.forEach(player => playCountMap[player[0]]++);
            
            // è®°å½•æœ€åé…å¯¹
            lastPairingForPlayer[fixedPair[0][0]] = fixedPair[1][0];
            lastPairingForPlayer[fixedPair[1][0]] = fixedPair[0][0];
            lastPairingForPlayer[opponentPair[0][0]] = opponentPair[1][0];
            lastPairingForPlayer[opponentPair[1][0]] = opponentPair[0][0];
            
            const pair1Type = getPairingType([fixedPair[0][0], fixedPair[1][0]], allPlayers);
            const pair2Type = getPairingType([opponentPair[0][0], opponentPair[1][0]], allPlayers);
            const levelDiff = (fixedPair[0][1] + fixedPair[1][1]) - (opponentPair[0][1] + opponentPair[1][1]);
            const pairingTypeText = pair1Type === pair2Type ?
              (pair1Type === 'men' ? 'ç”·åŒ' :
               pair1Type === 'women' ? 'å¥³åŒ' : 'æ··åŒ') : 'æ··åˆ';
            
            return [
              fixedPair,
              opponentPair,
              levelDiff,
              pair1Type,
              pair2Type
            ];
          }
        }
      }

      // å®Œå…¨ç§»é™¤ä¸Šæ¬¡é…å¯¹çš„ä¿æŒé€»è¾‘

      // æ²¡æœ‰å›ºå®šé…å¯¹æ—¶çš„å¸¸è§„é…å¯¹ç”Ÿæˆé€»è¾‘
      // å½“æ°´å¹³å·®è¾ƒå¤§æ—¶è°ƒæ•´é…å¯¹
      return generateBalancedPairs(availablePlayers, allPlayers, pairingType);
    }

    // ç”Ÿæˆå¹³è¡¡é…å¯¹çš„å‡½æ•°ï¼ˆè€ƒè™‘æ°´å¹³å·®ï¼‰
    function generateBalancedPairs(players, allPlayers, pairingType) {
      // æƒé‡ç³»æ•°è®¾ç½®
      const WEIGHTS = {
        levelDiff: 0.01,    // æ°´å¹³å·®çš„æƒé‡
        unpairing: 999999,   // æœªå¯¹æˆ˜é…å¯¹çš„æƒé‡ (å¤§å¹…å¢åŠ )
        playCount: 0.000001,    // å‡ºåœºæ¬¡æ•°çš„æƒé‡
        pairingHistory: 999999999999999 // é¿å…ä¸å·²å¯¹æˆ˜è¿‡çš„é…å¯¹é‡å¤çš„æƒé‡
      };
      
      // åˆ†æ•°è®¡ç®—å‡½æ•°
      const calculateScore = (pair1, pair2) => {
        const pair1Level = pair1[0][1] + pair1[1][1];
        const pair2Level = pair2[0][1] + pair2[1][1];
        const levelDiff = Math.abs(pair1Level - pair2Level);
        
        // æœªå¯¹æˆ˜é…å¯¹çš„åˆ†æ•°
        const pair1Key = [pair1[0][0], pair1[1][0]].sort().join(' & ');
        const pair2Key = [pair2[0][0], pair2[1][0]].sort().join(' & ');
        
        // å¦‚æœæ˜¯æœªå¯¹æˆ˜é…å¯¹ï¼Œåˆ™å¤§å¹…é™ä½åˆ†æ•°
        const unpairScore1 = (pairingCounts[pair1Key] || 0) === 0 ? WEIGHTS.unpairing : 0;
        const unpairScore2 = (pairingCounts[pair2Key] || 0) === 0 ? WEIGHTS.unpairing : 0;
        const unpairScore = unpairScore1 + unpairScore2;
        
        // å‡ºåœºæ¬¡æ•°åˆ†æ•°ï¼ˆå‡ºåœºå°‘çš„ä¼˜å…ˆï¼‰
        const playCountScore = 
          (Math.max(playCountMap[pair1[0][0]], playCountMap[pair1[1][0]]) +
           Math.max(playCountMap[pair2[0][0]], playCountMap[pair2[1][0]])) * WEIGHTS.playCount;
        
        // é¿å…ä¸å·²å¯¹æˆ˜è¿‡çš„é…å¯¹é‡å¤çš„åˆ†æ•°
        let historyScore = 0;
        if (pairingHistory[pair1Key] && pairingHistory[pair1Key].some(h => h.opponent === pair2Key)) {
          historyScore += WEIGHTS.pairingHistory;
        }
        if (pairingHistory[pair2Key] && pairingHistory[pair2Key].some(h => h.opponent === pair1Key)) {
          historyScore += WEIGHTS.pairingHistory;
        }
        
        // ç»¼åˆåˆ†æ•°ï¼ˆè¶Šå°è¶Šå¥½ï¼‰
        return levelDiff * WEIGHTS.levelDiff - unpairScore + playCountScore + historyScore;
      };

      // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„é…å¯¹ç»„åˆ
      const allPossiblePairs = [];
      for (let i = 0; i < players.length; i++) {
        for (let j = i + 1; j < players.length; j++) {
          allPossiblePairs.push([players[i], players[j]]);
        }
      }

      // ç­›é€‰ç¬¦åˆé…å¯¹ç±»å‹çš„é…å¯¹
      const filteredPairs = allPossiblePairs.filter(pair => {
        const player1 = allPlayers.find(p => p.name === pair[0][0]);
        const player2 = allPlayers.find(p => p.name === pair[1][0]);
        
        if (!player1 || !player2) return false;
        
        // é…å¯¹ç±»å‹æ£€æŸ¥
        if (pairingType === 'men') {
          return player1.gender === 'male' && player2.gender === 'male';
        } else if (pairingType === 'women') {
          return player1.gender === 'female' && player2.gender === 'female';
        } else if (pairingType === 'mix') {
          return (player1.gender === 'male' && player2.gender === 'female') || 
                 (player1.gender === 'female' && player2.gender === 'male');
        }
        return true; // 'any'æ—¶å…è®¸æ‰€æœ‰ç±»å‹
      });

      // å¯»æ‰¾æœ€ä¼˜çš„é…å¯¹ç»„åˆ
      let bestScore = Infinity;
      let bestPair1 = null;
      let bestPair2 = null;
      
      for (let i = 0; i < filteredPairs.length; i++) {
        for (let j = i + 1; j < filteredPairs.length; j++) {
          const pair1 = filteredPairs[i];
          const pair2 = filteredPairs[j];
          
          // æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤çƒå‘˜
          if (pair1[0][0] === pair2[0][0] || pair1[0][0] === pair2[1][0] ||
              pair1[1][0] === pair2[0][0] || pair1[1][0] === pair2[1][0]) {
            continue;
          }
          
          const currentScore = calculateScore(pair1, pair2);
          
          // å¦‚æœæ°´å¹³å·®å¤§äºç­‰äº3ï¼Œåˆ™å°è¯•é‡æ–°åˆ†é…
          const pair1Level = pair1[0][1] + pair1[1][1];
          const pair2Level = pair2[0][1] + pair2[1][1];
          const levelDiff = Math.abs(pair1Level - pair2Level);
          
          if (levelDiff >= 3) {
            // æ°´å¹³å·®è¿‡å¤§æ—¶ï¼Œå°è¯•é‡æ–°åˆ†é…
            const reassigned = reassignForBalance([...pair1, ...pair2], allPlayers, pairingType);
            if (reassigned) {
              const reassignedScore = calculateScore([reassigned[0], reassigned[1]], [reassigned[2], reassigned[3]]);
              if (reassignedScore < currentScore) {
                // æ›´æ–°é…å¯¹ç»„åˆå†å²
                const pair1Key = [reassigned[0][0], reassigned[1][0]].sort().join(' & ');
                const pair2Key = [reassigned[2][0], reassigned[3][0]].sort().join(' & ');
                
                pairingHistory[pair1Key].push({
                  round: allRoundData.length + 1,
                  opponent: pair2Key,
                  type: getPairingType([reassigned[0][0], reassigned[1][0]], allPlayers)
                });
                
                pairingHistory[pair2Key].push({
                  round: allRoundData.length + 1,
                  opponent: pair1Key,
                  type: getPairingType([reassigned[2][0], reassigned[3][0]], allPlayers)
                });
                
                return [
                  [reassigned[0], reassigned[1]],
                  [reassigned[2], reassigned[3]],
                  (reassigned[0][1] + reassigned[1][1]) - (reassigned[2][1] + reassigned[3][1]),
                  getPairingType([reassigned[0][0], reassigned[1][0]], allPlayers),
                  getPairingType([reassigned[2][0], reassigned[3][0]], allPlayers)
                ];
              }
            }
          }
          
          if (currentScore < bestScore) {
            bestScore = currentScore;
            bestPair1 = pair1;
            bestPair2 = pair2;
          }
        }
      }
      
      if (bestPair1 && bestPair2) {
        const pair1Type = getPairingType([bestPair1[0][0], bestPair1[1][0]], allPlayers);
        const pair2Type = getPairingType([bestPair2[0][0], bestPair2[1][0]], allPlayers);
        const levelDiff = (bestPair1[0][1] + bestPair1[1][1]) - (bestPair2[0][1] + bestPair2[1][1]);
        
        // æ›´æ–°é…å¯¹ç»„åˆå†å²
        const pair1Key = [bestPair1[0][0], bestPair1[1][0]].sort().join(' & ');
        const pair2Key = [bestPair2[0][0], bestPair2[1][0]].sort().join(' & ');
        
        pairingHistory[pair1Key].push({
          round: allRoundData.length + 1,
          opponent: pair2Key,
          type: pair1Type
        });
        
        pairingHistory[pair2Key].push({
          round: allRoundData.length + 1,
          opponent: pair1Key,
          type: pair2Type
        });
        
        // è®°å½•æœ€åé…å¯¹
        lastPairingForPlayer[bestPair1[0][0]] = bestPair1[1][0];
        lastPairingForPlayer[bestPair1[1][0]] = bestPair1[0][0];
        lastPairingForPlayer[bestPair2[0][0]] = bestPair2[1][0];
        lastPairingForPlayer[bestPair2[1][0]] = bestPair2[0][0];
        
        return [
          bestPair1,
          bestPair2,
          levelDiff,
          pair1Type,
          pair2Type
        ];
      }
      
      return [[], [], 0, '', ''];
    }

    // æ°´å¹³å·®è¿‡å¤§æ—¶é‡æ–°åˆ†é…é…å¯¹çš„å‡½æ•°
    function reassignForBalance(players, allPlayers, pairingType) {
      if (players.length !== 4) return null;
      
      // å°è¯•æ‰€æœ‰å¯èƒ½çš„ç»„åˆ
      const combinations = [
        [0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 1, 2]
      ];
      
      let bestCombination = players;
      let minLevelDiff = Infinity;
      
      for (const combo of combinations) {
        const pair1 = [players[combo[0]], players[combo[1]]];
        const pair2 = [players[combo[2]], players[combo[3]]];
        
        // é…å¯¹ç±»å‹æ£€æŸ¥
        const pair1Type = getPairingType([pair1[0][0], pair1[1][0]], allPlayers);
        const pair2Type = getPairingType([pair2[0][0], pair2[1][0]], allPlayers);
        
        let valid = true;
        if (pairingType === 'men') {
          valid = pair1Type === 'men' && pair2Type === 'men';
        } else if (pairingType === 'women') {
          valid = pair1Type === 'women' && pair2Type === 'women';
        } else if (pairingType === 'mix') {
          valid = pair1Type === 'mix' && pair2Type === 'mix';
        }
        
        if (!valid) continue;
        
        const currentDiff = Math.abs(
          (pair1[0][1] + pair1[1][1]) - 
          (pair2[0][1] + pair2[1][1])
        );
        
        if (currentDiff < minLevelDiff) {
          minLevelDiff = currentDiff;
          bestCombination = [pair1[0], pair1[1], pair2[0], pair2[1]];
        }
      }
      
      return minLevelDiff < Infinity ? bestCombination : null;
    }

    // è€ƒè™‘æ°´å¹³å·®é€‰æ‹©å¯¹æ‰‹é…å¯¹çš„å‡½æ•°ï¼ˆç”¨äºå›ºå®šé…å¯¹ï¼‰
    function selectOpponentsConsideringLevel(fixedPair, remainingPlayers, allPlayers, pairingType) {
      const fixedPairLevel = fixedPair[0][1] + fixedPair[1][1];
      
      // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¯¹æ‰‹é…å¯¹
      const possibleOpponentPairs = [];
      for (let i = 0; i < remainingPlayers.length; i++) {
        for (let j = i + 1; j < remainingPlayers.length; j++) {
          possibleOpponentPairs.push([remainingPlayers[i], remainingPlayers[j]]);
        }
      }
      
      // ç­›é€‰ç¬¦åˆé…å¯¹ç±»å‹çš„é…å¯¹
      const filteredPairs = possibleOpponentPairs.filter(pair => {
        const player1 = allPlayers.find(p => p.name === pair[0][0]);
        const player2 = allPlayers.find(p => p.name === pair[1][0]);
        
        if (!player1 || !player2) return false;
        
        // é…å¯¹ç±»å‹æ£€æŸ¥
        if (pairingType === 'men') {
          return player1.gender === 'male' && player2.gender === 'male';
        } else if (pairingType === 'women') {
          return player1.gender === 'female' && player2.gender === 'female';
        } else if (pairingType === 'mix') {
          return (player1.gender === 'male' && player2.gender === 'female') || 
                 (player1.gender === 'female' && player2.gender === 'male');
        }
        return true; // 'any'æ—¶å…è®¸æ‰€æœ‰ç±»å‹
      });
      
      if (filteredPairs.length === 0) {
        return remainingPlayers.slice(0, 2); // æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„é…å¯¹æ—¶éšæœºé€‰æ‹©
      }
      
      // é€‰æ‹©æ°´å¹³å·®æœ€å°çš„é…å¯¹
      let bestPair = filteredPairs[0];
      let minLevelDiff = Math.abs(fixedPairLevel - (bestPair[0][1] + bestPair[1][1]));
      
      for (const pair of filteredPairs) {
        const currentLevelDiff = Math.abs(fixedPairLevel - (pair[0][1] + pair[1][1]));
        if (currentLevelDiff < minLevelDiff) {
          minLevelDiff = currentLevelDiff;
          bestPair = pair;
        }
      }
      
      return bestPair;
    }

    function createMatchRow(courtNumber, a, b, diff, pair1Type, pair2Type, pairingTypeText, isFixedPair = false) {
      const pair1TypeClass = pair1Type === 'men' ? 'men' : pair1Type === 'women' ? 'women' : 'mix';
      const pair2TypeClass = pair2Type === 'men' ? 'men' : pair2Type === 'women' ? 'women' : 'mix';

      const diffWarning = Math.abs(diff) > 3 ? `<span class="level-diff-warning"> (å·®è·è¿‡å¤§!)</span>` : '';
      const fixedPairClass = isFixedPair ? 'fixed-pair-highlight' : '';

      return `<tr class="${fixedPairClass}">
        <td>åœºåœ° ${courtNumber}</td>
        <td><span class="bold-text">${a[0][0]} & ${a[1][0]} <span class="pairing-type ${pair1TypeClass}">${pair1Type === 'men' ? 'ç”·åŒ' : pair1Type === 'women' ? 'å¥³åŒ' : 'æ··åŒ'}</span></span></td>
        <td><span class="bold-text">${b[0][0]} & ${b[1][0]} <span class="pairing-type ${pair2TypeClass}">${pair2Type === 'men' ? 'ç”·åŒ' : pair2Type === 'women' ? 'å¥³åŒ' : 'æ··åŒ'}</span></span></td>
        <td><span class="bold-text">${diff}${diffWarning}</span></td>
        <td>${pairingTypeText}${isFixedPair ? ' (å›ºå®šé…å¯¹)' : ''}</td>
      </tr>`;
    }

    function createStatistics(playCountMap, pairingCounts, allPlayers, currentPairingType) {
      let html = "<h3>ğŸ… æ€»å‡ºåœºç»Ÿè®¡</h3><table><tr><th>çƒå‘˜</th><th>å‡ºåœºæ¬¡æ•°</th></tr>";
      Object.entries(playCountMap).forEach(([name, count]) => {
        html += `<tr><td>${name}</td><td>${count}</td></tr>`;
      });
      html += "</table>";

      html += `<div class="pairing-stats"><h3>ğŸ¤ é…å¯¹ç»Ÿè®¡ (${getPairingTypeName(currentPairingType)})</h3>`;
      html += "<table><tr><th>é…å¯¹</th><th>ç±»å‹</th><th>ç»„åˆæ¬¡æ•°</th><th>æ°´å¹³æ€»å’Œ</th><th>å¯¹æˆ˜å†å²</th></tr>";

      const sortedPairs = allPossiblePairs.sort((a, b) => {
        // æœªå¯¹æˆ˜é…å¯¹ä¼˜å…ˆæ˜¾ç¤º
        if (pairingCounts[a] === 0 && pairingCounts[b] > 0) return -1;
        if (pairingCounts[a] > 0 && pairingCounts[b] === 0) return 1;
        // ç„¶åæŒ‰å¯¹æˆ˜æ¬¡æ•°ä»å°‘åˆ°å¤šæ’åº
        return (pairingCounts[a] || 0) - (pairingCounts[b] || 0);
      });

      sortedPairs.forEach(pair => {
        const [player1, player2] = pair.split(' & ');
        const player1Data = allPlayers.find(p => p.name === player1);
        const player2Data = allPlayers.find(p => p.name === player2);
        let pairType = 'unknown';

        if (player1Data && player2Data) {
          if (player1Data.gender === 'male' && player2Data.gender === 'male') {
            pairType = 'ç”·åŒ';
          } else if (player1Data.gender === 'female' && player2Data.gender === 'female') {
            pairType = 'å¥³åŒ';
          } else {
            pairType = 'æ··åŒ';
          }
        }

        const count = pairingCounts[pair] || 0;
        const levelSum = playerLevelSumMap[pair] || (player1Data?.level || 0) + (player2Data?.level || 0);
        
        // æ˜¾ç¤ºå¯¹æˆ˜å†å²
        const history = pairingHistory[pair] || [];
        const historyText = history.map(h => `R${h.round}: ${h.opponent} (${h.type})`).join('<br>');

        // æœªå¯¹æˆ˜é…å¯¹é«˜äº®æ˜¾ç¤º
        const highlightClass = count === 0 ? 'unpaired-highlight' : '';

        html += `<tr class="${highlightClass}">
          <td>${pair}</td>
          <td>${pairType}</td>
          <td>${count}æ¬¡</td>
          <td>${levelSum}</td>
          <td>${historyText || '-'}</td>
        </tr>`;
      });

      // æ˜¾ç¤ºæœªå¯¹æˆ˜é…å¯¹æ•°é‡
      const unpairedCount = sortedPairs.filter(pair => (pairingCounts[pair] || 0) === 0).length;
      html += `<tr><td colspan="5" style="text-align: center; font-weight: bold; background-color: ${unpairedCount > 0 ? '#fff8e1' : '#e8f5e9'}">
        æœªå¯¹æˆ˜é…å¯¹: ${unpairedCount}ç»„ / å…±${sortedPairs.length}ç»„
      </td></tr>`;

      html += "</table></div>";

      return html;
    }

    function generateRounds(pairingType = 'any', outputElementId = 'output') {
      currentPairingType = pairingType;
      const names = document.getElementById("playerNames").value.trim().split("\n");
      const levelInput = document.getElementById("playerLevels").value.trim().split("\n");
      const genderInput = document.getElementById("playerGenders").value.trim().split("\n");
      const joinRoundInput = document.getElementById("playerJoinRounds").value.trim().split("\n");
      const courtCount = parseInt(document.getElementById("courtCount").value);
      const totalRounds = parseInt(document.getElementById("totalRounds").value);
      const output = document.getElementById(outputElementId);
      if (output) output.innerHTML = "";

      collectRestSettings();
      collectFixedPairs();
      collectJoinRoundSettings();

      const players = [];
      const allPlayers = [];
      let maleCount = 0;
      let femaleCount = 0;

      for (let i = 0; i < names.length; i++) {
        const name = names[i].trim();
        let level = parseInt(levelInput[i]) || Math.floor(Math.random() * 5) + 1;
        let gender = (genderInput[i] || 'male').trim();
        let joinRound = parseInt(joinRoundInput[i]) || 1;
        if (name) {
          players.push([name, level]);
          allPlayers.push({ name, level, gender, joinRound });
          if (gender === 'male') maleCount++;
          else femaleCount++;
        }
      }

      initializePairingCounts(allPlayers);
      playCountMap = {};
      players.forEach(p => playCountMap[p[0]] = 0);

      let fullHtml = `
        <div class="player-count-info">
          å·²æ³¨å†Œçƒå‘˜: ç”· ${maleCount}äºº, å¥³ ${femaleCount}äºº, æ€»è®¡ ${players.length}äºº
        </div>
      `;

      let currentRoundPairs = [];
      allRoundData = [];
      allPreviousPairs = [];

      for (let roundNumber = 1; roundNumber <= totalRounds; roundNumber++) {
        let availablePlayers = [...players];
        const restingPlayers = getRestingPlayers(roundNumber);
        availablePlayers = availablePlayers.filter(player => !restingPlayers.includes(player[0]));

        // æ ¹æ®å‚åŠ è½®æ¬¡ç­›é€‰
        availablePlayers = availablePlayers.filter(player => {
          const playerInfo = allPlayers.find(p => p.name === player[0]);
          return playerInfo && playerInfo.joinRound <= roundNumber;
        });

        // å‡ºåœºæ¬¡æ•°å°‘çš„çƒå‘˜ä¼˜å…ˆ
        availablePlayers.sort((a, b) => playCountMap[a[0]] - playCountMap[b[0]]);

        const malePlayers = availablePlayers.filter(p => {
          const player = allPlayers.find(ap => ap.name === p[0]);
          return player && player.gender === 'male';
        });

        const femalePlayers = availablePlayers.filter(p => {
          const player = allPlayers.find(ap => ap.name === p[0]);
          return player && player.gender === 'female';
        });

        let selectedPlayers = [];
        let warningMessage = "";

        if (pairingType === 'men') {
          const maxPossiblePairs = Math.min(Math.floor(malePlayers.length / 2), courtCount);
          selectedPlayers = malePlayers.slice(0, maxPossiblePairs * 2);

          if (malePlayers.length < 4) {
            warningMessage = `<p class="warning-message">âš ï¸ ç”·çƒå‘˜ä¸è¶³ (${malePlayers.length}äºº)ã€‚ç»„æˆç”·åŒè‡³å°‘éœ€è¦4äººã€‚</p>`;
          }
        } else if (pairingType === 'women') {
          const maxPossiblePairs = Math.min(Math.floor(femalePlayers.length / 2), courtCount);
          selectedPlayers = femalePlayers.slice(0, maxPossiblePairs * 2);

          if (femalePlayers.length < 4) {
            warningMessage = `<p class="warning-message">âš ï¸ å¥³çƒå‘˜ä¸è¶³ (${femalePlayers.length}äºº)ã€‚ç»„æˆå¥³åŒè‡³å°‘éœ€è¦4äººã€‚</p>`;
          }
        } else if (pairingType === 'mix') {
          const maxPossiblePairs = Math.min(Math.min(malePlayers.length, femalePlayers.length), courtCount);
          for (let i = 0; i < maxPossiblePairs; i++) {
            if (malePlayers[i] && femalePlayers[i]) {
              selectedPlayers.push(malePlayers[i]);
              selectedPlayers.push(femalePlayers[i]);
            }
          }

          if (malePlayers.length < 2 || femalePlayers.length < 2) {
            warningMessage = `<p class="warning-message">âš ï¸ ç»„æˆæ··åŒéœ€è¦ç”·å¥³å„è‡³å°‘2äºº (ç”·: ${malePlayers.length}äºº, å¥³: ${femalePlayers.length}äºº)ã€‚</p>`;
          }
        } else {
          const maxPossiblePlayers = Math.min(availablePlayers.length, courtCount * 4);
          selectedPlayers = availablePlayers.slice(0, maxPossiblePlayers);

          if (availablePlayers.length < 4) {
            warningMessage = `<p class="warning-message">âš ï¸ çƒå‘˜ä¸è¶³ (${availablePlayers.length}äºº)ã€‚ç»„æˆåŒæ‰“è‡³å°‘éœ€è¦4äººã€‚</p>`;
          }
        }

        let html = `<h3>ç¬¬ ${roundNumber} è½® (${getPairingTypeName(pairingType)})</h3>`;

        if (warningMessage) {
          html += warningMessage;
        }

        if (restingPlayers.length > 0) {
          html += `<p>ä¼‘æ¯ä¸­çš„çƒå‘˜: ${restingPlayers.join(', ')}</p>`;
        }

        // æ˜¾ç¤ºæœ¬è½®å‚åŠ çš„çƒå‘˜
        const joiningPlayers = allPlayers.filter(p => p.joinRound <= roundNumber && !restingPlayers.includes(p.name));
        html += `<p>å‚åŠ çƒå‘˜ (${joiningPlayers.length}äºº): ${joiningPlayers.map(p => p.name).join(', ')}</p>`;

        html += "<table><tr><th>åœºåœ°</th><th>é˜Ÿä¼ A</th><th>é˜Ÿä¼ B</th><th>A-B å·®</th><th>ç±»å‹</th></tr>";

        currentRoundPairs = [];
        const roundData = {
          roundNumber: roundNumber,
          courts: []
        };

        let assignedPlayers = new Set();
        let courtNumber = 1;
        let remainingPlayersList = [];
        
        // è·å–å½“å‰è½®æ¬¡çš„å›ºå®šé…å¯¹
        const roundFixedPairs = fixedPairs.filter(fp => fp.round === roundNumber);

        // å¦‚æœæœ‰å›ºå®šé…å¯¹ï¼Œä¼˜å…ˆåˆ†é…
        if (roundFixedPairs.length > 0) {
          for (const fp of roundFixedPairs) {
            if (courtNumber > courtCount) break;
            
            const player1 = selectedPlayers.find(p => p[0] === fp.player1);
            const player2 = selectedPlayers.find(p => p[0] === fp.player2);
            
            if (player1 && player2 && !assignedPlayers.has(player1[0]) && !assignedPlayers.has(player2[0])) {
              // é€‰æ‹©å›ºå®šé…å¯¹çš„å¯¹æ‰‹
              const availableOpponents = selectedPlayers.filter(
                p => !assignedPlayers.has(p[0]) && p[0] !== player1[0] && p[0] !== player2[0]
              );
              
              if (availableOpponents.length >= 2) {
                // ç”Ÿæˆä¸å›ºå®šé…å¯¹å¯¹æˆ˜çš„é…å¯¹ï¼ˆå¿½ç•¥æ°´å¹³å·®ï¼‰
                shuffle(availableOpponents);
                const opponentPair = availableOpponents.slice(0, 2);
                
                if (opponentPair.length === 2) {
                  const pair1Key = [player1[0], player2[0]].sort().join(' & ');
                  const pair2Key = [opponentPair[0][0], opponentPair[1][0]].sort().join(' & ');
                  currentRoundPairs.push(pair1Key, pair2Key);

                  pairingCounts[pair1Key] = (pairingCounts[pair1Key] || 0) + 1;
                  pairingCounts[pair2Key] = (pairingCounts[pair2Key] || 0) + 1;
                  
                  // æ›´æ–°é…å¯¹ç»„åˆå†å²
                  pairingHistory[pair1Key].push({
                    round: roundNumber,
                    opponent: pair2Key,
                    type: getPairingType([player1[0], player2[0]], allPlayers)
                  });
                  
                  pairingHistory[pair2Key].push({
                    round: roundNumber,
                    opponent: pair1Key,
                    type: getPairingType([opponentPair[0][0], opponentPair[1][0]], allPlayers)
                  });
                  
                  playCountMap[player1[0]]++;
                  playCountMap[player2[0]]++;
                  playCountMap[opponentPair[0][0]]++;
                  playCountMap[opponentPair[1][0]]++;

                  const pair1Type = getPairingType([player1[0], player2[0]], allPlayers);
                  const pair2Type = getPairingType([opponentPair[0][0], opponentPair[1][0]], allPlayers);
                  const levelDiff = (player1[1] + player2[1]) - (opponentPair[0][1] + opponentPair[1][1]);
                  const pairingTypeText = pair1Type === pair2Type ?
                    (pair1Type === 'men' ? 'ç”·åŒ' :
                     pair1Type === 'women' ? 'å¥³åŒ' : 'æ··åŒ') : 'æ··åˆ';

                  html += createMatchRow(courtNumber, 
                    [[player1[0], player1[1]], [player2[0], player2[1]]], 
                    [[opponentPair[0][0], opponentPair[0][1]], [opponentPair[1][0], opponentPair[1][1]]], 
                    levelDiff, pair1Type, pair2Type, pairingTypeText, true);

                  assignedPlayers.add(player1[0]);
                  assignedPlayers.add(player2[0]);
                  assignedPlayers.add(opponentPair[0][0]);
                  assignedPlayers.add(opponentPair[1][0]);

                  roundData.courts.push({
                    courtNumber: courtNumber,
                    members: [player1[0], player2[0], opponentPair[0][0], opponentPair[1][0]],
                    isFreePractice: false
                  });

                  courtNumber++;
                }
              }
            }
          }
        }

        // ä¸ºå‰©ä½™åœºåœ°åˆ†é…å¸¸è§„é…å¯¹
        while (courtNumber <= courtCount) {
          const availableForCourt = selectedPlayers.filter(p => !assignedPlayers.has(p[0]));

          if (availableForCourt.length >= 4) {
            const [a, b, diff, pair1Type, pair2Type] = createPairs(availableForCourt, allPlayers, pairingType, roundNumber);

            if (a && b && a.length > 0 && b.length > 0) {
              const pair1Key = [a[0][0], a[1][0]].sort().join(' & ');
              const pair2Key = [b[0][0], b[1][0]].sort().join(' & ');
              currentRoundPairs.push(pair1Key, pair2Key);

              pairingCounts[pair1Key] = (pairingCounts[pair1Key] || 0) + 1;
              pairingCounts[pair2Key] = (pairingCounts[pair2Key] || 0) + 1;
              
              // æ›´æ–°é…å¯¹ç»„åˆå†å²
              pairingHistory[pair1Key].push({
                round: roundNumber,
                opponent: pair2Key,
                type: pair1Type
              });
              
              pairingHistory[pair2Key].push({
                round: roundNumber,
                opponent: pair1Key,
                type: pair2Type
              });
              
              a.forEach(player => playCountMap[player[0]]++);
              b.forEach(player => playCountMap[player[0]]++);

              const pairingTypeText = pair1Type === pair2Type ?
                (pair1Type === 'men' ? 'ç”·åŒ' :
                 pair1Type === 'women' ? 'å¥³åŒ' : 'æ··åŒ') : 'æ··åˆ';

              html += createMatchRow(courtNumber, a, b, diff, pair1Type, pair2Type, pairingTypeText);

              assignedPlayers.add(a[0][0]);
              assignedPlayers.add(a[1][0]);
              assignedPlayers.add(b[0][0]);
              assignedPlayers.add(b[1][0]);

              roundData.courts.push({
                courtNumber: courtNumber,
                members: [...a, ...b].map(p => p[0]),
                isFreePractice: false
              });

              courtNumber++;
              continue;
            }
          }

          const remainingPlayers = availableForCourt.map(p => p[0]);
          if (remainingPlayers.length > 0) {
            remainingPlayersList.push(...remainingPlayers);
            html += `<tr>
              <td>åœºåœ° ${courtNumber}</td>
              <td colspan="3">è‡ªç”±ç»ƒä¹  <span class="remaining-players">(å‰©ä½™: ${remainingPlayers.join(', ')})</span></td>
              <td>æ— </td>
            </tr>`;
          } else {
            html += `<tr><td>åœºåœ° ${courtNumber}</td><td colspan="3">è‡ªç”±ç»ƒä¹ </td><td>æ— </td></tr>`;
          }

          roundData.courts.push({
            courtNumber: courtNumber,
            members: remainingPlayers,
            isFreePractice: true
          });

          courtNumber++;
        }

        if (remainingPlayersList.length > 0) {
          html += `<p class="remaining-players">æœªåˆ†é…çƒå‘˜: ${[...new Set(remainingPlayersList)].join(', ')}</p>`;
        }

        html += "</table>";
        fullHtml += html;
        allPreviousPairs = [...allPreviousPairs, ...currentRoundPairs];
        allRoundData.push(roundData);
      }

      fullHtml += createStatistics(playCountMap, pairingCounts, allPlayers, currentPairingType);
      if (output) output.innerHTML = fullHtml;
      initializeCourtDynamics();

      // ä¿å­˜åˆ†äº«æ•°æ®
      currentShareData = {
        court: courtCount,
        rounds: totalRounds,
        names: names.join('\n'),
        levels: levelInput.join('\n'),
        genders: genderInput.join('\n'),
        joinRounds: joinRoundInput.join('\n'),
        restSettings: restSettings,
        fixedPairs: fixedPairs,
        joinRoundSettings: joinRoundSettings,
        eventInfo: {
          name: document.getElementById("eventName").value.trim(),
          location: document.getElementById("eventLocation").value.trim(),
          date: document.getElementById("eventDate").value,
          time: document.getElementById("eventTime").value
        },
        registeredPlayers: registeredPlayers,
        teams: teams
      };

      return fullHtml;
    }

    function getPairingTypeName(type) {
      switch(type) {
        case 'any': return 'éšæœº';
        case 'mix': return 'æ··åŒ';
        case 'men': return 'ç”·åŒ';
        case 'women': return 'å¥³åŒ';
        default: return '';
      }
    }

    function addRestControl() {
      const container = document.getElementById('restContainer');
      const restId = Date.now();

      const restItem = document.createElement('div');
      restItem.className = 'rest-item';
      restItem.id = `restItem-${restId}`;

      const playerSelect = document.createElement('select');
      playerSelect.id = `restPlayer-${restId}`;
      playerSelect.multiple = true;
      playerSelect.style.height = 'auto';

      const roundInput = document.createElement('input');
      roundInput.type = 'number';
      roundInput.id = `restRound-${restId}`;
      roundInput.min = '1';
      roundInput.placeholder = 'ä¼‘æ¯è½®æ¬¡';

      const removeBtn = document.createElement('button');
      removeBtn.textContent = 'åˆ é™¤';
      removeBtn.onclick = function() {
        container.removeChild(restItem);
        restSettings = restSettings.filter(item => item.id !== restId);
      };

      restItem.appendChild(playerSelect);
      restItem.appendChild(roundInput);
      restItem.appendChild(removeBtn);

      container.appendChild(restItem);

      updatePlayerSelects();

      return restId;
    }
    
    function addFixedPairControl() {
      const container = document.getElementById('fixedPairContainer');
      const pairId = Date.now();

      const pairItem = document.createElement('div');
      pairItem.className = 'fixed-pair-item';
      pairItem.id = `fixedPairItem-${pairId}`;

      const player1Select = document.createElement('select');
      player1Select.id = `fixedPairPlayer1-${pairId}`;

      const player2Select = document.createElement('select');
      player2Select.id = `fixedPairPlayer2-${pairId}`;

      const roundInput = document.createElement('input');
      roundInput.type = 'number';
      roundInput.id = `fixedPairRound-${pairId}`;
      roundInput.min = '1';
      roundInput.placeholder = 'è½®æ¬¡ç¼–å·';

      const removeBtn = document.createElement('button');
      removeBtn.textContent = 'åˆ é™¤';
      removeBtn.onclick = function() {
        container.removeChild(pairItem);
        fixedPairs = fixedPairs.filter(item => item.id !== pairId);
      };

      pairItem.appendChild(player1Select);
      pairItem.appendChild(player2Select);
      pairItem.appendChild(roundInput);
      pairItem.appendChild(removeBtn);

      container.appendChild(pairItem);

      updatePlayerSelects();

      return pairId;
    }
    
    function addJoinRoundControl() {
      const container = document.getElementById('joinRoundContainer');
      const joinRoundId = Date.now();

      const joinRoundItem = document.createElement('div');
      joinRoundItem.className = 'join-round-item';
      joinRoundItem.id = `joinRoundItem-${joinRoundId}`;

      const playerSelect = document.createElement('select');
      playerSelect.id = `joinRoundPlayer-${joinRoundId}`;

      const roundInput = document.createElement('input');
      roundInput.type = 'number';
      roundInput.id = `joinRoundRound-${joinRoundId}`;
      roundInput.min = '1';
      roundInput.placeholder = 'å¼€å§‹å‚åŠ çš„è½®æ¬¡';

      const removeBtn = document.createElement('button');
      removeBtn.textContent = 'åˆ é™¤';
      removeBtn.onclick = function() {
        container.removeChild(joinRoundItem);
        joinRoundSettings = joinRoundSettings.filter(item => item.id !== joinRoundId);
      };

      joinRoundItem.appendChild(playerSelect);
      joinRoundItem.appendChild(roundInput);
      joinRoundItem.appendChild(removeBtn);

      container.appendChild(joinRoundItem);

      updatePlayerSelects();

      return joinRoundId;
    }

    function updatePlayerSelects() {
      const names = document.getElementById("playerNames").value.trim().split("\n");

      const allPlayers = names.filter(name => name.trim() !== '');

      // æ›´æ–°ä¼‘æ¯è®¾ç½®çš„çƒå‘˜é€‰æ‹©åˆ—è¡¨
      const restSelects = document.querySelectorAll('select[id^="restPlayer-"]');
      restSelects.forEach(select => {
        const selectedValues = Array.from(select.selectedOptions).map(option => option.value);

        select.innerHTML = '';
        allPlayers.forEach(player => {
          const option = document.createElement('option');
          option.value = player.trim();
          option.textContent = player.trim();
          select.appendChild(option);
        });

        selectedValues.forEach(value => {
          const option = Array.from(select.options).find(opt => opt.value === value);
          if (option) option.selected = true;
        });
      });
      
      // æ›´æ–°å›ºå®šé…å¯¹çš„çƒå‘˜é€‰æ‹©åˆ—è¡¨
      const pairSelects1 = document.querySelectorAll('select[id^="fixedPairPlayer1-"]');
      const pairSelects2 = document.querySelectorAll('select[id^="fixedPairPlayer2-"]');
      
      pairSelects1.forEach(select => {
        const currentValue = select.value;
        select.innerHTML = '';
        allPlayers.forEach(player => {
          const option = document.createElement('option');
          option.value = player.trim();
          option.textContent = player.trim();
          select.appendChild(option);
        });
        if (currentValue) select.value = currentValue;
      });
      
      pairSelects2.forEach(select => {
        const currentValue = select.value;
        select.innerHTML = '';
        allPlayers.forEach(player => {
          const option = document.createElement('option');
          option.value = player.trim();
          option.textContent = player.trim();
          select.appendChild(option);
        });
        if (currentValue) select.value = currentValue;
      });
      
      // æ›´æ–°å‚åŠ è½®æ¬¡çš„çƒå‘˜é€‰æ‹©åˆ—è¡¨
      const joinRoundSelects = document.querySelectorAll('select[id^="joinRoundPlayer-"]');
      
      joinRoundSelects.forEach(select => {
        const currentValue = select.value;
        select.innerHTML = '';
        allPlayers.forEach(player => {
          const option = document.createElement('option');
          option.value = player.trim();
          option.textContent = player.trim();
          select.appendChild(option);
        });
        if (currentValue) select.value = currentValue;
      });
    }

    function collectFixedPairs() {
      fixedPairs = [];
      const pairItems = document.querySelectorAll('.fixed-pair-item');

      pairItems.forEach(item => {
        const id = item.id.replace('fixedPairItem-', '');
        const player1Select = document.getElementById(`fixedPairPlayer1-${id}`);
        const player2Select = document.getElementById(`fixedPairPlayer2-${id}`);
        const roundInput = document.getElementById(`fixedPairRound-${id}`);

        if (player1Select && player2Select && roundInput && roundInput.value) {
          const player1 = player1Select.value;
          const player2 = player2Select.value;
          const round = parseInt(roundInput.value);

          if (player1 && player2 && !isNaN(round)) {
            fixedPairs.push({
              id: id,
              player1: player1,
              player2: player2,
              round: round
            });
          }
        }
      });
    }
    
    function collectJoinRoundSettings() {
      joinRoundSettings = [];
      const joinRoundItems = document.querySelectorAll('.join-round-item');

      joinRoundItems.forEach(item => {
        const id = item.id.replace('joinRoundItem-', '');
        const playerSelect = document.getElementById(`joinRoundPlayer-${id}`);
        const roundInput = document.getElementById(`joinRoundRound-${id}`);

        if (playerSelect && roundInput && roundInput.value) {
          const player = playerSelect.value;
          const round = parseInt(roundInput.value);

          if (player && !isNaN(round)) {
            joinRoundSettings.push({
              id: id,
              player: player,
              round: round
            });
          }
        }
      });
      
      // å°†å‚åŠ è½®æ¬¡è®¾ç½®åæ˜ åˆ°çƒå‘˜ä¿¡æ¯ä¸­
      registeredPlayers.forEach(player => {
        const setting = joinRoundSettings.find(s => s.player === player.name);
        if (setting) {
          player.joinRound = setting.round;
        } else {
          // æ²¡æœ‰è®¾ç½®æ—¶é»˜è®¤ä»ç¬¬1è½®å¼€å§‹å‚åŠ 
          player.joinRound = 1;
        }
      });
    }

    function initializeCourtDynamics() {
      const courtCount = parseInt(document.getElementById("courtCount").value) || 1;
      const totalRounds = parseInt(document.getElementById("totalRounds").value) || 1;

      courtRoundSettings = {};
      for (let i = 1; i <= courtCount; i++) {
        courtRoundSettings[i] = 1;
      }
    }

    function showCourtDynamicsPopup() {
      const popup = document.getElementById('courtDynamicsPopup');
      popup.style.display = 'flex';
      updateCourtDynamics();
    }

    function closeCourtDynamicsPopup() {
      document.getElementById('courtDynamicsPopup').style.display = 'none';
    }

    function updateCourtDynamics() {
      const courtCount = parseInt(document.getElementById("courtCount").value) || 1;
      const dynamicsOutput = document.getElementById('dynamicsOutput');

      let html = '<div class="court-members">';

      for (let courtNumber = 1; courtNumber <= courtCount; courtNumber++) {
        const roundNumber = courtRoundSettings[courtNumber] || 1;

        const roundData = allRoundData.find(round => round.roundNumber === roundNumber);
        const courtData = roundData?.courts.find(court => court.courtNumber === courtNumber);

        html += '<div class="court-box">';
        html += `<div class="court-title">
          <span>åœºåœ° ${courtNumber}</span>
          <div class="court-round-control">
            <button onclick="changeCourtRound(${courtNumber}, -1)">â—€</button>
            <input type="number" id="courtRoundInput-${courtNumber}"
                   value="${roundNumber}" min="1"
                   onchange="setCourtRound(${courtNumber}, this.value)">
            <button onclick="changeCourtRound(${courtNumber}, 1)">â–¶</button>
          </div>
        </div>`;

        if (!courtData || courtData.isFreePractice) {
          const remaining = courtData?.members?.length > 0 ?
            `<span class="free-practice">(å‰©ä½™: ${courtData.members.join(', ')})</span>` : '';
          html += '<ul class="member-list"><li class="free-practice">è‡ªç”±ç»ƒä¹  ' + remaining + '</li></ul>';
        } else {
          html += '<ul class="member-list">';
          courtData.members.forEach(member => {
            html += `<li>${member}</li>`;
          });
          html += '</ul>';
        }

        html += '</div>';
      }

      html += '</div>';
      dynamicsOutput.innerHTML = html;
    }

    function changeCourtRound(courtNumber, delta) {
      const currentRound = courtRoundSettings[courtNumber] || 1;
      const totalRounds = parseInt(document.getElementById("totalRounds").value) || 1;
      const newRound = Math.max(1, Math.min(totalRounds, currentRound + delta));

      courtRoundSettings[courtNumber] = newRound;
      document.getElementById(`courtRoundInput-${courtNumber}`).value = newRound;
      updateCourtDynamics();
    }

    function setCourtRound(courtNumber, round) {
      const totalRounds = parseInt(document.getElementById("totalRounds").value) || 1;
      const newRound = Math.max(1, Math.min(totalRounds, parseInt(round) || 1));

      courtRoundSettings[courtNumber] = newRound;
      updateCourtDynamics();
    }

    function collectRestSettings() {
      restSettings = [];
      const restItems = document.querySelectorAll('.rest-item');

      restItems.forEach(item => {
        const id = item.id.replace('restItem-', '');
        const playerSelect = document.getElementById(`restPlayer-${id}`);
        const roundInput = document.getElementById(`restRound-${id}`);

        if (playerSelect && roundInput && roundInput.value) {
          const players = Array.from(playerSelect.selectedOptions).map(option => option.value);
          const round = parseInt(roundInput.value);

          if (players.length > 0 && !isNaN(round)) {
            restSettings.push({
              id: id,
              players: players,
              round: round
            });
          }
        }
      });
    }

    function getRestingPlayers(roundNumber) {
      const restingPlayers = [];
      restSettings.forEach(setting => {
        if (setting.round === roundNumber) {
          restingPlayers.push(...setting.players);
        }
      });
      return [...new Set(restingPlayers)];
    }

    function generateShareLink() {
      try {
        const courtCount = document.getElementById("courtCount").value;
        const totalRounds = document.getElementById("totalRounds").value;
        const playerNames = document.getElementById("playerNames").value.trim();
        const playerLevels = document.getElementById("playerLevels").value.trim();
        const playerGenders = document.getElementById("playerGenders").value.trim();
        const playerJoinRounds = document.getElementById("playerJoinRounds").value.trim();

        // è·å–æ´»åŠ¨ä¿¡æ¯
        const eventName = document.getElementById("eventName").value.trim();
        const eventLocation = document.getElementById("eventLocation").value.trim();
        const eventDate = document.getElementById("eventDate").value;
        const eventTime = document.getElementById("eventTime").value;

        collectRestSettings();
        collectFixedPairs();
        collectJoinRoundSettings();

        const data = {
          court: courtCount,
          rounds: totalRounds,
          names: playerNames,
          levels: playerLevels,
          genders: playerGenders,
          joinRounds: playerJoinRounds,
          restSettings: restSettings,
          fixedPairs: fixedPairs,
          joinRoundSettings: joinRoundSettings,
          // æ·»åŠ æ´»åŠ¨ä¿¡æ¯
          eventInfo: {
            name: eventName,
            location: eventLocation,
            date: eventDate,
            time: eventTime
          },
          registeredPlayers: registeredPlayers,
          teams: teams
        };

        const encodedData = encodeURIComponent(JSON.stringify(data));
        const shareURL = `${window.location.origin}${window.location.pathname}?data=${encodedData}`;

        document.getElementById("shareLink").value = shareURL;
        return true;
      } catch (error) {
        console.error("ç”Ÿæˆåˆ†äº«é“¾æ¥é”™è¯¯:", error);
        alert("ç”Ÿæˆåˆ†äº«é“¾æ¥å¤±è´¥");
        return false;
      }
    }

    function copyShareLink() {
      const linkInput = document.getElementById("shareLink");
      linkInput.select();
      linkInput.setSelectionRange(0, 99999);
      document.execCommand("copy");
      alert("é“¾æ¥å·²å¤åˆ¶ï¼");
    }

    function loadRestSettings(settings) {
      const container = document.getElementById('restContainer');
      container.innerHTML = '';

      settings.forEach(setting => {
        const restId = addRestControl();

        const playerSelect = document.getElementById(`restPlayer-${restId}`);
        const roundInput = document.getElementById(`restRound-${restId}`);

        if (playerSelect && roundInput) {
          setting.players.forEach(player => {
            const option = Array.from(playerSelect.options).find(opt => opt.value === player);
            if (option) option.selected = true;
          });

          roundInput.value = setting.round;
        }
      });
    }
    
    function loadFixedPairs(settings) {
      const container = document.getElementById('fixedPairContainer');
      container.innerHTML = '';

      settings.forEach(setting => {
        const pairId = addFixedPairControl();

        const player1Select = document.getElementById(`fixedPairPlayer1-${pairId}`);
        const player2Select = document.getElementById(`fixedPairPlayer2-${pairId}`);
        const roundInput = document.getElementById(`fixedPairRound-${pairId}`);

        if (player1Select && player2Select && roundInput) {
          player1Select.value = setting.player1;
          player2Select.value = setting.player2;
          roundInput.value = setting.round;
        }
      });
    }
    
    function loadJoinRoundSettings(settings) {
      const container = document.getElementById('joinRoundContainer');
      container.innerHTML = '';

      settings.forEach(setting => {
        const joinRoundId = addJoinRoundControl();

        const playerSelect = document.getElementById(`joinRoundPlayer-${joinRoundId}`);
        const roundInput = document.getElementById(`joinRoundRound-${joinRoundId}`);

        if (playerSelect && roundInput) {
          playerSelect.value = setting.player;
          roundInput.value = setting.round;
        }
      });
    }

    function saveData() {
      const data = {
        eventName: document.getElementById("eventName").value,
        eventLocation: document.getElementById("eventLocation").value,
        eventDate: document.getElementById("eventDate").value,
        eventTime: document.getElementById("eventTime").value,
        registeredPlayers: registeredPlayers,
        teams: teams,
        teamDivisionData: {
          courtCount: document.getElementById("courtCount").value,
          totalRounds: document.getElementById("totalRounds").value,
          playerNames: document.getElementById("playerNames").value,
          playerLevels: document.getElementById("playerLevels").value,
          playerGenders: document.getElementById("playerGenders").value,
          playerJoinRounds: document.getElementById("playerJoinRounds").value,
          restSettings: restSettings,
          fixedPairs: fixedPairs,
          joinRoundSettings: joinRoundSettings
        }
      };

      localStorage.setItem('badmintonTeamToolData', JSON.stringify(data));
      alert('æ•°æ®å·²ä¿å­˜');
    }

    function loadData() {
      const savedData = localStorage.getItem('badmintonTeamToolData');
      if (!savedData) {
        alert('æœªæ‰¾åˆ°ä¿å­˜çš„æ•°æ®');
        return;
      }

      try {
        const data = JSON.parse(savedData);

        document.getElementById("eventName").value = data.eventName || "";
        document.getElementById("eventLocation").value = data.eventLocation || "";
        document.getElementById("eventDate").value = data.eventDate || "";
        document.getElementById("eventTime").value = data.eventTime || "";

        if (data.registeredPlayers) {
          registeredPlayers = data.registeredPlayers;
          updateRegisteredPlayersList();
        }

        if (data.teams) {
          teams = data.teams;
          updateTeamList();
          updateTeamSelector();
        }

        if (data.teamDivisionData) {
          const td = data.teamDivisionData;
          document.getElementById("courtCount").value = td.courtCount || "";
          document.getElementById("totalRounds").value = td.totalRounds || "";
          document.getElementById("playerNames").value = td.playerNames || "";
          document.getElementById("playerLevels").value = td.playerLevels || "";
          document.getElementById("playerGenders").value = td.playerGenders || "";
          document.getElementById("playerJoinRounds").value = td.playerJoinRounds || "";

          if (td.restSettings) {
            loadRestSettings(td.restSettings);
          }
          
          if (td.fixedPairs) {
            loadFixedPairs(td.fixedPairs);
          }
          
          if (td.joinRoundSettings) {
            loadJoinRoundSettings(td.joinRoundSettings);
          }
        }

        alert('æ•°æ®å·²åŠ è½½');
      } catch (error) {
        console.error('æ•°æ®åŠ è½½é”™è¯¯:', error);
        alert('åŠ è½½æ•°æ®å¤±è´¥');
      }
    }

    function exportData() {
      const data = {
        eventName: document.getElementById("eventName").value,
        eventLocation: document.getElementById("eventLocation").value,
        eventDate: document.getElementById("eventDate").value,
        eventTime: document.getElementById("eventTime").value,
        registeredPlayers: registeredPlayers,
        teams: teams,
        teamDivisionData: {
          courtCount: document.getElementById("courtCount").value,
          totalRounds: document.getElementById("totalRounds").value,
          playerNames: document.getElementById("playerNames").value,
          playerLevels: document.getElementById("playerLevels").value,
          playerGenders: document.getElementById("playerGenders").value,
          playerJoinRounds: document.getElementById("playerJoinRounds").value,
          restSettings: restSettings,
          fixedPairs: fixedPairs,
          joinRoundSettings: joinRoundSettings
        }
      };

      const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'badminton-team-data.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function importData(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);

          document.getElementById("eventName").value = data.eventName || "";
          document.getElementById("eventLocation").value = data.eventLocation || "";
          document.getElementById("eventDate").value = data.eventDate || "";
          document.getElementById("eventTime").value = data.eventTime || "";

          if (data.registeredPlayers) {
            registeredPlayers = data.registeredPlayers;
            updateRegisteredPlayersList();
          }

          if (data.teams) {
            teams = data.teams;
            updateTeamList();
            updateTeamSelector();
          }

          if (data.teamDivisionData) {
            const td = data.teamDivisionData;
            document.getElementById("courtCount").value = td.courtCount || "";
            document.getElementById("totalRounds").value = td.totalRounds || "";
            document.getElementById("playerNames").value = td.playerNames || "";
            document.getElementById("playerLevels").value = td.playerLevels || "";
            document.getElementById("playerGenders").value = td.playerGenders || "";
            document.getElementById("playerJoinRounds").value = td.playerJoinRounds || "";

            if (td.restSettings) {
              loadRestSettings(td.restSettings);
            }
            
            if (td.fixedPairs) {
              loadFixedPairs(td.fixedPairs);
            }
            
            if (td.joinRoundSettings) {
              loadJoinRoundSettings(td.joinRoundSettings);
            }
          }

          alert('æ•°æ®å·²å¯¼å…¥');
        } catch (error) {
          console.error('å¯¼å…¥é”™è¯¯:', error);
          alert('è¯»å–æ–‡ä»¶å¤±è´¥');
        }
      };
      reader.readAsText(file);
    }

    function exportToExcel() {
      try {
        // æ£€æŸ¥æ•°æ®æ˜¯å¦å­˜åœ¨
        if (!currentShareData || !allRoundData || allRoundData.length === 0) {
          alert("è¯·å…ˆç”Ÿæˆå›¢é˜Ÿåˆ†é…æ•°æ®");
          return;
        }

        // 1. å‡†å¤‡æ•°æ®
        let csvContent = "æ•°æ®,å†…å®¹\n";

        // æ´»åŠ¨ä¿¡æ¯
        if (currentShareData.eventInfo) {
          const ei = currentShareData.eventInfo;
          csvContent += `æ´»åŠ¨åç§°,${ei.name || ''}\n`;
          csvContent += `åœ°ç‚¹,${ei.location || ''}\n`;
          csvContent += `æ—¥æœŸ,${ei.date || ''}\n`;
          csvContent += `æ—¶é—´,${ei.time || ''}\n\n`;
        }

        // çƒå‘˜åˆ—è¡¨
        csvContent += "çƒå‘˜åˆ—è¡¨\nå§“å,æ°´å¹³,æ€§åˆ«,å‚åŠ è½®æ¬¡\n";
        const names = currentShareData.names.split('\n');
        const levels = currentShareData.levels.split('\n');
        const genders = currentShareData.genders.split('\n');
        const joinRounds = currentShareData.joinRounds.split('\n');

        for (let i = 0; i < names.length; i++) {
          const name = names[i].trim();
          if (name) {
            const level = levels[i] || '3';
            const gender = genders[i] === 'male' ? 'ç”·' : genders[i] === 'female' ? 'å¥³' : genders[i] || 'ç”·';
            const joinRound = joinRounds[i] || '1';
            csvContent += `${name},${level},${gender},${joinRound}\n`;
          }
        }
        csvContent += "\n";

        // å›¢é˜Ÿä¿¡æ¯
        if (currentShareData.teams && currentShareData.teams.length > 0) {
          csvContent += "å›¢é˜Ÿä¿¡æ¯\n";
          currentShareData.teams.forEach(team => {
            csvContent += `å›¢é˜Ÿåç§°,${team.name}\n`;
            csvContent += "æˆå‘˜,æ°´å¹³,æ€§åˆ«\n";
            team.members.forEach(member => {
              csvContent += `${member.name},${member.level},${member.gender === 'male' ? 'ç”·' : 'å¥³'}\n`;
            });
            csvContent += "\n";
          });
        }

        // è½®æ¬¡ä¿¡æ¯
        allRoundData.forEach(round => {
          csvContent += `ç¬¬ ${round.roundNumber} è½®\n`;
          csvContent += "åœºåœ°,é˜Ÿä¼A,é˜Ÿä¼B,A-Bå·®,ç±»å‹\n";

          const restingPlayers = getRestingPlayers(round.roundNumber);
          if (restingPlayers.length > 0) {
            csvContent += `ä¼‘æ¯ä¸­çš„çƒå‘˜,${restingPlayers.join(', ')},,,\n`;
          }

          // æ˜¾ç¤ºå‚åŠ çƒå‘˜
          const joiningPlayers = currentShareData.registeredPlayers.filter(p => 
            p.joinRound <= round.roundNumber && !restingPlayers.includes(p.name)
          );
          csvContent += `å‚åŠ çƒå‘˜,${joiningPlayers.map(p => p.name).join(', ')},,,\n`;

          round.courts.forEach(court => {
            if (court.isFreePractice) {
              const members = court.members.length > 0 ? ` (${court.members.join(', ')})` : '';
              csvContent += `åœºåœ° ${court.courtNumber},è‡ªç”±ç»ƒä¹ ${members},,,\n`;
            } else {
              const teamA = court.members.slice(0, 2).join(" & ");
              const teamB = court.members.slice(2, 4).join(" & ");

              // è®¡ç®—æ°´å¹³å·®
              const allPlayers = names.map((name, i) => ({
                name: name.trim(),
                level: parseInt(levels[i]) || 3
              })).filter(p => p.name);

              const teamALevel = court.members.slice(0, 2).reduce((sum, name) => {
                const player = allPlayers.find(p => p.name === name);
                return sum + (player ? player.level : 0);
              }, 0);

              const teamBLevel = court.members.slice(2, 4).reduce((sum, name) => {
                const player = allPlayers.find(p => p.name === name);
                return sum + (player ? player.level : 0);
              }, 0);

              const levelDiff = teamALevel - teamBLevel;

              // è·å–é…å¯¹ç±»å‹
              const player1 = allPlayers.find(p => p.name === court.members[0]);
              const player2 = allPlayers.find(p => p.name === court.members[1]);
              const player3 = allPlayers.find(p => p.name === court.members[2]);
              const player4 = allPlayers.find(p => p.name === court.members[3]);

              let pairType = '';
              if (player1 && player2 && player3 && player4) {
                const type1 = player1.gender === 'male' && player2.gender === 'male' ? 'ç”·åŒ' :
                             player1.gender === 'female' && player2.gender === 'female' ? 'å¥³åŒ' : 'æ··åŒ';
                const type2 = player3.gender === 'male' && player4.gender === 'male' ? 'ç”·åŒ' :
                             player3.gender === 'female' && player4.gender === 'female' ? 'å¥³åŒ' : 'æ··åŒ';
                pairType = type1 === type2 ?
                          (type1 === 'ç”·åŒ' ? 'ç”·åŒ' :
                           type1 === 'å¥³åŒ' ? 'å¥³åŒ' : 'æ··åŒ') : 'æ··åˆ';
              }

              // æ£€æŸ¥æ˜¯å¦ä¸ºå›ºå®šé…å¯¹
              const isFixedPair = fixedPairs.some(fp => 
                fp.round === round.roundNumber && 
                ((fp.player1 === court.members[0] && fp.player2 === court.members[1]) || 
                 (fp.player1 === court.members[1] && fp.player2 === court.members[0]))
              );
              
              if (isFixedPair) {
                pairType += ' (å›ºå®šé…å¯¹)';
              }

              csvContent += `åœºåœ° ${court.courtNumber},${teamA},${teamB},${levelDiff},${pairType}\n`;
            }
          });
          csvContent += "\n";
        });

        // 2. åˆ›å»ºä¸‹è½½é“¾æ¥
        const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;

        const eventName = currentShareData.eventInfo?.name || 'badminton';
        link.download = `${eventName.replace(/[^a-z0-9]/gi, '_')}_å›¢é˜Ÿåˆ†ç»„.csv`;

        // 3. è§¦å‘ä¸‹è½½
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

      } catch (error) {
        console.error("å¯¼å‡ºExcelæ—¶å‡ºé”™:", error);
        alert(`å¯¼å‡ºå¤±è´¥: ${error.message}`);
      }
    }

    function openInNewWindow(pairingType) {
      const newWindow = window.open('', '_blank');
      const html = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>ç¾½æ¯›çƒåˆ†ç»„ç»“æœ - ${getPairingTypeName(pairingType)}</title>
          <style>
            body {
              font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
              padding: 20px;
              background: #f4f4f4;
              color: #000;
            }
            table {
              border-collapse: collapse;
              width: 100%;
              margin-top: 20px;
              background-color: white;
              border-radius: 10px;
              overflow: hidden;
            }
            th, td {
              border: 1px solid #ddd;
              padding: 12px;
              text-align: center;
              font-size: 16px;
            }
            th {
              background-color: #4CAF50;
              color: white;
            }
            .bold-text {
              font-weight: bold;
              color: black;
            }
            .pairing-type {
              display: inline-block;
              padding: 2px 6px;
              border-radius: 4px;
              font-size: 12px;
              margin-left: 5px;
            }
            .pairing-type.men {
              background-color: #2196F3;
              color: white;
            }
            .pairing-type.women {
              background-color: #E91E63;
              color: white;
            }
            .pairing-type.mix {
              background-color: #4CAF50;
              color: white;
            }
            .pairing-stats {
              margin-top: 20px;
              background-color: white;
              padding: 20px;
              border-radius: 10px;
            }
            .warning-message {
              color: #d32f2f;
              font-weight: bold;
              margin: 10px 0;
            }
            .player-count-info {
              background-color: #e3f2fd;
              padding: 10px;
              border-radius: 5px;
              margin-bottom: 15px;
              font-weight: bold;
            }
            .remaining-players {
              color: #616161;
              font-style: italic;
              margin-top: 5px;
            }
            .level-diff-warning {
              color: #FF9800;
              font-weight: bold;
            }
            .unpaired-highlight {
              background-color: #fffde7;
            }
            .fixed-pair-highlight {
              background-color: #e8f5e9;
            }
          </style>
        </head>
        <body>
          <h1>ç¾½æ¯›çƒåˆ†ç»„ç»“æœ - ${getPairingTypeName(pairingType)}</h1>
          <div id="output"></div>
          <button onclick="window.print()" style="margin-top: 20px; padding: 10px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">æ‰“å°</button>
        </body>
        </html>
      `;

      newWindow.document.open();
      newWindow.document.write(html);
      newWindow.document.close();

      setTimeout(() => {
        const names = document.getElementById("playerNames").value.trim().split("\n");
        const levelInput = document.getElementById("playerLevels").value.trim().split("\n");
        const genderInput = document.getElementById("playerGenders").value.trim().split("\n");
        const joinRoundInput = document.getElementById("playerJoinRounds").value.trim().split("\n");
        const courtCount = parseInt(document.getElementById("courtCount").value);
        const totalRounds = parseInt(document.getElementById("totalRounds").value);

        const players = [];
        const allPlayers = [];

        for (let i = 0; i < names.length; i++) {
          const name = names[i].trim();
          let level = parseInt(levelInput[i]) || Math.floor(Math.random() * 5) + 1;
          let gender = (genderInput[i] || 'male').trim();
          let joinRound = parseInt(joinRoundInput[i]) || 1;
          if (name) {
            players.push([name, level]);
            allPlayers.push({ name, level, gender, joinRound });
          }
        }

        const output = newWindow.document.getElementById("output");
        const result = generateRounds.call({
          document: newWindow.document,
          getElementById: (id) => newWindow.document.getElementById(id),
        }, pairingType, "output");

        output.innerHTML = result;
      }, 500);
    }

    window.addEventListener("DOMContentLoaded", () => {
      const params = new URLSearchParams(window.location.search);

      if (params.has("data")) {
        try {
          const data = JSON.parse(decodeURIComponent(params.get("data")));

          document.getElementById("courtCount").value = data.court || 1;
          document.getElementById("totalRounds").value = data.rounds || 1;
          document.getElementById("playerNames").value = data.names || "";
          document.getElementById("playerLevels").value = data.levels || "";
          document.getElementById("playerGenders").value = data.genders || "";
          document.getElementById("playerJoinRounds").value = data.joinRounds || "";

          // æ¢å¤æ´»åŠ¨ä¿¡æ¯
          if (data.eventInfo) {
            document.getElementById("eventName").value = data.eventInfo.name || "";
            document.getElementById("eventLocation").value = data.eventInfo.location || "";
            document.getElementById("eventDate").value = data.eventInfo.date || "";
            document.getElementById("eventTime").value = data.eventInfo.time || "";
          }

          if (data.registeredPlayers) {
            registeredPlayers = data.registeredPlayers;
            updateRegisteredPlayersList();
          }

          if (data.teams) {
            teams = data.teams;
            updateTeamList();
            updateTeamSelector();
          }

          if (data.restSettings) {
            loadRestSettings(data.restSettings);
          }
          
          if (data.fixedPairs) {
            loadFixedPairs(data.fixedPairs);
          }
          
          if (data.joinRoundSettings) {
            loadJoinRoundSettings(data.joinRoundSettings);
          }

          document.querySelectorAll('.tab-content').forEach(tab => {
            tab.classList.remove('active');
          });
          document.getElementById('teamTab').classList.add('active');

          document.querySelectorAll('.tab').forEach(tab => {
            tab.classList.remove('active');
          });
          document.querySelector('.tab-container button:nth-child(3)').classList.add('active');

          generateRounds('any');
        } catch (e) {
          console.error("æ•°æ®åŠ è½½é”™è¯¯:", e);
          alert("åŠ è½½åˆ†äº«æ•°æ®å¤±è´¥");
        }
      }

      document.getElementById("playerNames").addEventListener("input", updatePlayerSelects);

      // åˆå§‹åŒ–æ°´å¹³æ»‘å—
      initializeLevelSlider();

      loadData();
    });
  </script>
</body>
</html>
